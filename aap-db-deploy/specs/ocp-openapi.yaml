openapi: 3.0.1
info:
  title: Kubernetes
  version: v1.29.6+aba1e8d
servers:
  - url: /
security:
  - BearerToken: []
paths:
  /apis/apps/v1/namespaces/{namespace}/deployments:
    post:
      tags:
        - apps_v1
      description: create a Deployment
      operationId: createAppsV1NamespacedDeployment
      parameters:
        - name: namespace
          in: path
          description: namespace
          required: true
          schema:
            type: string
        - name: dryRun
          in: query
          description:
            "When present, indicates that modifications should not be persisted.\
            \ An invalid or unrecognized dryRun directive will result in an error response\
            \ and no further processing of the request. Valid values are: - All: all\
            \ dry run stages will be processed"
          schema:
            type: string
        - name: fieldManager
          in: query
          description:
            "fieldManager is a name associated with the actor or entity that\
            \ is making these changes. The value must be less than or 128 characters\
            \ long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
          schema:
            type: string
        - name: fieldValidation
          in: query
          description:
            "fieldValidation instructs the server on how to handle objects\
            \ in the request (POST/PUT/PATCH) containing unknown or duplicate fields.\
            \ Valid values are: - Ignore: This will ignore any unknown fields that are\
            \ silently dropped from the object, and will ignore all but the last duplicate\
            \ field that the decoder encounters. This is the default behavior prior\
            \ to v1.23. - Warn: This will send a warning via the standard warning response\
            \ header for each unknown field that is dropped from the object, and for\
            \ each duplicate field that is encountered. The request will still succeed\
            \ if there are no other errors, and will only persist the last of any duplicate\
            \ fields. This is the default in v1.23+ - Strict: This will fail the request\
            \ with a BadRequest error if any unknown fields would be dropped from the\
            \ object, or if any duplicate fields are present. The error returned from\
            \ the server will contain all unknown and duplicate fields encountered."
          schema:
            type: string
      requestBody:
        content:
          "*/*":
            schema:
              $ref: "#/components/schemas/io.k8s.api.apps.v1.Deployment"
        required: true
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/io.k8s.api.apps.v1.Deployment"
            application/yaml:
              schema:
                $ref: "#/components/schemas/io.k8s.api.apps.v1.Deployment"
            application/vnd.kubernetes.protobuf:
              schema:
                $ref: "#/components/schemas/io.k8s.api.apps.v1.Deployment"
        "201":
          description: Created
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/io.k8s.api.apps.v1.Deployment"
            application/yaml:
              schema:
                $ref: "#/components/schemas/io.k8s.api.apps.v1.Deployment"
            application/vnd.kubernetes.protobuf:
              schema:
                $ref: "#/components/schemas/io.k8s.api.apps.v1.Deployment"
        "202":
          description: Accepted
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/io.k8s.api.apps.v1.Deployment"
            application/yaml:
              schema:
                $ref: "#/components/schemas/io.k8s.api.apps.v1.Deployment"
            application/vnd.kubernetes.protobuf:
              schema:
                $ref: "#/components/schemas/io.k8s.api.apps.v1.Deployment"
        "401":
          description: Unauthorized
          content: {}
      x-kubernetes-action: post
      x-kubernetes-group-version-kind:
        group: apps
        kind: Deployment
        version: v1
      x-codegen-request-body-name: body
  /apis/apps/v1/namespaces/{namespace}/deployments/{name}:
    get:
      tags:
        - apps_v1
      description: read the specified Deployment
      operationId: readAppsV1NamespacedDeployment
      parameters:
        - name: namespace
          in: path
          description: namespace
          required: true
          schema:
            type: string
        - name: name
          in: path
          description: name
          required: true
          schema:
            type: string
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/io.k8s.api.apps.v1.Deployment"
            application/yaml:
              schema:
                $ref: "#/components/schemas/io.k8s.api.apps.v1.Deployment"
            application/vnd.kubernetes.protobuf:
              schema:
                $ref: "#/components/schemas/io.k8s.api.apps.v1.Deployment"
        "401":
          description: Unauthorized
          content: {}
      x-kubernetes-action: get
      x-kubernetes-group-version-kind:
        group: apps
        kind: Deployment
        version: v1
  /api/v1/namespaces/{namespace}/services:
    post:
      tags:
        - core_v1
      description: create a Service
      operationId: createCoreV1NamespacedService
      parameters:
        - name: namespace
          in: path
          description: namespace
          required: true
          schema:
            type: string
        - name: dryRun
          in: query
          description:
            "When present, indicates that modifications should not be persisted.\
            \ An invalid or unrecognized dryRun directive will result in an error response\
            \ and no further processing of the request. Valid values are: - All: all\
            \ dry run stages will be processed"
          schema:
            type: string
        - name: fieldManager
          in: query
          description:
            "fieldManager is a name associated with the actor or entity that\
            \ is making these changes. The value must be less than or 128 characters\
            \ long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
          schema:
            type: string
        - name: fieldValidation
          in: query
          description:
            "fieldValidation instructs the server on how to handle objects\
            \ in the request (POST/PUT/PATCH) containing unknown or duplicate fields.\
            \ Valid values are: - Ignore: This will ignore any unknown fields that are\
            \ silently dropped from the object, and will ignore all but the last duplicate\
            \ field that the decoder encounters. This is the default behavior prior\
            \ to v1.23. - Warn: This will send a warning via the standard warning response\
            \ header for each unknown field that is dropped from the object, and for\
            \ each duplicate field that is encountered. The request will still succeed\
            \ if there are no other errors, and will only persist the last of any duplicate\
            \ fields. This is the default in v1.23+ - Strict: This will fail the request\
            \ with a BadRequest error if any unknown fields would be dropped from the\
            \ object, or if any duplicate fields are present. The error returned from\
            \ the server will contain all unknown and duplicate fields encountered."
          schema:
            type: string
      requestBody:
        content:
          "*/*":
            schema:
              $ref: "#/components/schemas/io.k8s.api.core.v1.Service"
        required: true
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/io.k8s.api.core.v1.Service"
            application/yaml:
              schema:
                $ref: "#/components/schemas/io.k8s.api.core.v1.Service"
            application/vnd.kubernetes.protobuf:
              schema:
                $ref: "#/components/schemas/io.k8s.api.core.v1.Service"
        "201":
          description: Created
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/io.k8s.api.core.v1.Service"
            application/yaml:
              schema:
                $ref: "#/components/schemas/io.k8s.api.core.v1.Service"
            application/vnd.kubernetes.protobuf:
              schema:
                $ref: "#/components/schemas/io.k8s.api.core.v1.Service"
        "202":
          description: Accepted
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/io.k8s.api.core.v1.Service"
            application/yaml:
              schema:
                $ref: "#/components/schemas/io.k8s.api.core.v1.Service"
            application/vnd.kubernetes.protobuf:
              schema:
                $ref: "#/components/schemas/io.k8s.api.core.v1.Service"
        "401":
          description: Unauthorized
          content: {}
      x-kubernetes-action: post
      x-kubernetes-group-version-kind:
        group: ""
        kind: Service
        version: v1
      x-codegen-request-body-name: body
  /apis/route.openshift.io/v1/namespaces/{namespace}/routes:
    post:
      tags:
        - routeOpenshiftIo_v1
      description: create a Route
      operationId: createRouteOpenshiftIoV1NamespacedRoute
      parameters:
        - name: namespace
          in: path
          description: namespace
          required: true
          schema:
            type: string
        - name: dryRun
          in: query
          description:
            "When present, indicates that modifications should not be persisted.\
            \ An invalid or unrecognized dryRun directive will result in an error response\
            \ and no further processing of the request. Valid values are: - All: all\
            \ dry run stages will be processed"
          schema:
            type: string
        - name: fieldManager
          in: query
          description:
            "fieldManager is a name associated with the actor or entity that\
            \ is making these changes. The value must be less than or 128 characters\
            \ long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
          schema:
            type: string
        - name: fieldValidation
          in: query
          description:
            "fieldValidation instructs the server on how to handle objects\
            \ in the request (POST/PUT/PATCH) containing unknown or duplicate fields.\
            \ Valid values are: - Ignore: This will ignore any unknown fields that are\
            \ silently dropped from the object, and will ignore all but the last duplicate\
            \ field that the decoder encounters. This is the default behavior prior\
            \ to v1.23. - Warn: This will send a warning via the standard warning response\
            \ header for each unknown field that is dropped from the object, and for\
            \ each duplicate field that is encountered. The request will still succeed\
            \ if there are no other errors, and will only persist the last of any duplicate\
            \ fields. This is the default in v1.23+ - Strict: This will fail the request\
            \ with a BadRequest error if any unknown fields would be dropped from the\
            \ object, or if any duplicate fields are present. The error returned from\
            \ the server will contain all unknown and duplicate fields encountered."
          schema:
            type: string
      requestBody:
        content:
          "*/*":
            schema:
              $ref: "#/components/schemas/com.github.openshift.api.route.v1.Route"
        required: true
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/com.github.openshift.api.route.v1.Route"
            application/yaml:
              schema:
                $ref: "#/components/schemas/com.github.openshift.api.route.v1.Route"
            application/vnd.kubernetes.protobuf:
              schema:
                $ref: "#/components/schemas/com.github.openshift.api.route.v1.Route"
        "201":
          description: Created
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/com.github.openshift.api.route.v1.Route"
            application/yaml:
              schema:
                $ref: "#/components/schemas/com.github.openshift.api.route.v1.Route"
            application/vnd.kubernetes.protobuf:
              schema:
                $ref: "#/components/schemas/com.github.openshift.api.route.v1.Route"
        "202":
          description: Accepted
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/com.github.openshift.api.route.v1.Route"
            application/yaml:
              schema:
                $ref: "#/components/schemas/com.github.openshift.api.route.v1.Route"
            application/vnd.kubernetes.protobuf:
              schema:
                $ref: "#/components/schemas/com.github.openshift.api.route.v1.Route"
        "401":
          description: Unauthorized
          content: {}
      x-kubernetes-action: post
      x-kubernetes-group-version-kind:
        group: route.openshift.io
        kind: Route
        version: v1
      x-codegen-request-body-name: body
  /apis/route.openshift.io/v1/namespaces/{namespace}/routes/{name}:
    get:
      tags:
        - routeOpenshiftIo_v1
      description: read the specified Route
      operationId: readRouteOpenshiftIoV1NamespacedRoute
      parameters:
        - name: namespace
          in: path
          description: namespace
          required: true
          schema:
            type: string
        - name: name
          in: path
          description: name
          required: true
          schema:
            type: string
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/com.github.openshift.api.route.v1.Route"
            application/yaml:
              schema:
                $ref: "#/components/schemas/com.github.openshift.api.route.v1.Route"
            application/vnd.kubernetes.protobuf:
              schema:
                $ref: "#/components/schemas/com.github.openshift.api.route.v1.Route"
        "401":
          description: Unauthorized
          content: {}
      x-kubernetes-action: get
      x-kubernetes-group-version-kind:
        group: route.openshift.io
        kind: Route
        version: v1
  /apis/route.openshift.io/v1/namespaces/{namespace}/routes/{name}/status:
    get:
      tags:
        - routeOpenshiftIo_v1
      description: read status of the specified Route
      operationId: readRouteOpenshiftIoV1NamespacedRouteStatus
      parameters:
        - name: namespace
          in: path
          description: namespace
          required: true
          schema:
            type: string
        - name: name
          in: path
          description: name
          required: true
          schema:
            type: string
      responses:
        "200":
          description: OK
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/com.github.openshift.api.route.v1.Route"
            application/yaml:
              schema:
                $ref: "#/components/schemas/com.github.openshift.api.route.v1.Route"
            application/vnd.kubernetes.protobuf:
              schema:
                $ref: "#/components/schemas/com.github.openshift.api.route.v1.Route"
        "401":
          description: Unauthorized
          content: {}
      x-kubernetes-action: get
      x-kubernetes-group-version-kind:
        group: route.openshift.io
        kind: Route
        version: v1
components:
  schemas:
    io.k8s.api.apps.v1.Deployment:
      type: object
      properties:
        apiVersion:
          type: string
          description:
            "APIVersion defines the versioned schema of this representation\
            \ of an object. Servers should convert recognized schemas to the latest\
            \ internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"
        kind:
          type: string
          description:
            "Kind is a string value representing the REST resource this\
            \ object represents. Servers may infer this from the endpoint the client\
            \ submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        metadata:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        spec:
          $ref: "#/components/schemas/io.k8s.api.apps.v1.DeploymentSpec"
        status:
          $ref: "#/components/schemas/io.k8s.api.apps.v1.DeploymentStatus"
      description: Deployment enables declarative updates for Pods and ReplicaSets.
      x-kubernetes-group-version-kind:
        - group: apps
          kind: Deployment
          version: v1
    io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta:
      type: object
      properties:
        annotations:
          type: object
          additionalProperties:
            type: string
          description:
            "Annotations is an unstructured key value map stored with a\
            \ resource that may be set by external tools to store and retrieve arbitrary\
            \ metadata. They are not queryable and should be preserved when modifying\
            \ objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations"
        creationTimestamp:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        deletionGracePeriodSeconds:
          type: integer
          description:
            Number of seconds allowed for this object to gracefully terminate
            before it will be removed from the system. Only set when deletionTimestamp
            is also set. May only be shortened. Read-only.
          format: int64
        deletionTimestamp:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        finalizers:
          type: array
          description:
            "Must be empty before the object is deleted from the registry.\
            \ Each entry is an identifier for the responsible component that will\
            \ remove the entry from the list. If the deletionTimestamp of the object\
            \ is non-nil, entries in this list can only be removed. Finalizers may\
            \ be processed and removed in any order.  Order is NOT enforced because\
            \ it introduces significant risk of stuck finalizers. finalizers is a\
            \ shared field, any actor with permission can reorder it. If the finalizer\
            \ list is processed in order, then this can lead to a situation in which\
            \ the component responsible for the first finalizer in the list is waiting\
            \ for a signal (field value, external system, or other) produced by a\
            \ component responsible for a finalizer later in the list, resulting in\
            \ a deadlock. Without enforced ordering finalizers are free to order amongst\
            \ themselves and are not vulnerable to ordering changes in the list."
          items:
            type: string
          x-kubernetes-patch-strategy: merge
        generateName:
          type: string
          description: |-
            GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.

            If this field is specified and the generated name exists, the server will return a 409.

            Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
        generation:
          type: integer
          description:
            A sequence number representing a specific generation of the
            desired state. Populated by the system. Read-only.
          format: int64
        labels:
          type: object
          additionalProperties:
            type: string
          description:
            "Map of string keys and values that can be used to organize\
            \ and categorize (scope and select) objects. May match selectors of replication\
            \ controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels"
        managedFields:
          type: array
          description:
            "ManagedFields maps workflow-id and version to the set of fields\
            \ that are managed by that workflow. This is mostly for internal housekeeping,\
            \ and users typically shouldn't need to set or understand this field.\
            \ A workflow can be the user's name, a controller's name, or the name\
            \ of a specific apply path like \"ci-cd\". The set of fields is always\
            \ in the version that the workflow used when modifying the object."
          items:
            $ref: "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry"
        name:
          type: string
          description:
            "Name must be unique within a namespace. Is required when creating\
            \ resources, although some resources may allow a client to request the\
            \ generation of an appropriate name automatically. Name is primarily intended\
            \ for creation idempotence and configuration definition. Cannot be updated.\
            \ More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names"
        namespace:
          type: string
          description: |-
            Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.

            Must be a DNS_LABEL. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
        ownerReferences:
          type: array
          description:
            "List of objects depended by this object. If ALL objects in\
            \ the list have been deleted, this object will be garbage collected. If\
            \ this object is managed by a controller, then an entry in this list will\
            \ point to this controller, with the controller field set to true. There\
            \ cannot be more than one managing controller."
          items:
            $ref: "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.OwnerReference"
          x-kubernetes-patch-strategy: merge
          x-kubernetes-patch-merge-key: uid
        resourceVersion:
          type: string
          description: |-
            An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.

            Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
        selfLink:
          type: string
          description:
            "Deprecated: selfLink is a legacy read-only field that is no\
            \ longer populated by the system."
        uid:
          type: string
          description: |-
            UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.

            Populated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
      description:
        "ObjectMeta is metadata that all persisted resources must have,\
        \ which includes all objects users must create."
    io.k8s.apimachinery.pkg.apis.meta.v1.Time:
      type: string
      description:
        Time is a wrapper around time.Time which supports correct marshaling
        to YAML and JSON.  Wrappers are provided for many of the factory methods that
        the time package offers.
      format: date-time
    io.k8s.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry:
      type: object
      properties:
        apiVersion:
          type: string
          description:
            APIVersion defines the version of this resource that this field
            set applies to. The format is "group/version" just like the top-level
            APIVersion field. It is necessary to track the version of a field set
            because it cannot be automatically converted.
        fieldsType:
          type: string
          description:
            "FieldsType is the discriminator for the different fields format\
            \ and version. There is currently only one possible value: \"FieldsV1\""
        fieldsV1:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.FieldsV1"
        manager:
          type: string
          description: Manager is an identifier of the workflow managing these fields.
        operation:
          type: string
          description:
            Operation is the type of operation which lead to this ManagedFieldsEntry
            being created. The only valid values for this field are 'Apply' and 'Update'.
        subresource:
          type: string
          description:
            "Subresource is the name of the subresource used to update\
            \ that object, or empty string if the object was updated through the main\
            \ resource. The value of this field is used to distinguish between managers,\
            \ even if they share the same name. For example, a status update will\
            \ be distinct from a regular update using the same manager name. Note\
            \ that the APIVersion field is not related to the Subresource field and\
            \ it always corresponds to the version of the main resource."
        time:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
      description:
        "ManagedFieldsEntry is a workflow-id, a FieldSet and the group\
        \ version of the resource that the fieldset applies to."
    io.k8s.apimachinery.pkg.apis.meta.v1.FieldsV1:
      type: object
      description: |-
        FieldsV1 stores a set of fields in a data structure like a Trie, in JSON format.

        Each key is either a '.' representing the field itself, and will always map to an empty set, or a string representing a sub-field or item. The string will follow one of these four formats: 'f:<name>', where <name> is the name of a field in a struct, or key in a map 'v:<value>', where <value> is the exact json formatted value of a list item 'i:<index>', where <index> is position of a item in a list 'k:<keys>', where <keys> is a map of  a list item's key fields to their unique values If a key maps to an empty Fields value, the field that key represents is part of the set.

        The exact format is defined in sigs.k8s.io/structured-merge-diff
    io.k8s.apimachinery.pkg.apis.meta.v1.OwnerReference:
      required:
        - apiVersion
        - kind
        - name
        - uid
      type: object
      properties:
        apiVersion:
          type: string
          description: API version of the referent.
        blockOwnerDeletion:
          type: boolean
          description:
            "If true, AND if the owner has the \"foregroundDeletion\" finalizer,\
            \ then the owner cannot be deleted from the key-value store until this\
            \ reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion\
            \ for how the garbage collector interacts with this field and enforces\
            \ the foreground deletion. Defaults to false. To set this field, a user\
            \ needs \"delete\" permission of the owner, otherwise 422 (Unprocessable\
            \ Entity) will be returned."
        controller:
          type: boolean
          description: "If true, this reference points to the managing controller."
        kind:
          type: string
          description: "Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        name:
          type: string
          description: "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names"
        uid:
          type: string
          description: "UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids"
      description:
        "OwnerReference contains enough information to let you identify\
        \ an owning object. An owning object must be in the same namespace as the\
        \ dependent, or be cluster-scoped, so there is no namespace field."
      x-kubernetes-map-type: atomic
    io.k8s.api.apps.v1.DeploymentSpec:
      required:
        - selector
        - template
      type: object
      properties:
        minReadySeconds:
          type: integer
          description:
            "Minimum number of seconds for which a newly created pod should\
            \ be ready without any of its container crashing, for it to be considered\
            \ available. Defaults to 0 (pod will be considered available as soon as\
            \ it is ready)"
          format: int32
        paused:
          type: boolean
          description: Indicates that the deployment is paused.
        progressDeadlineSeconds:
          type: integer
          description:
            The maximum time in seconds for a deployment to make progress
            before it is considered to be failed. The deployment controller will continue
            to process failed deployments and a condition with a ProgressDeadlineExceeded
            reason will be surfaced in the deployment status. Note that progress will
            not be estimated during the time a deployment is paused. Defaults to 600s.
          format: int32
        replicas:
          type: integer
          description:
            Number of desired pods. This is a pointer to distinguish between
            explicit zero and not specified. Defaults to 1.
          format: int32
        revisionHistoryLimit:
          type: integer
          description:
            The number of old ReplicaSets to retain to allow rollback.
            This is a pointer to distinguish between explicit zero and not specified.
            Defaults to 10.
          format: int32
        selector:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        strategy:
          $ref: "#/components/schemas/io.k8s.api.apps.v1.DeploymentStrategy"
        template:
          $ref: "#/components/schemas/io.k8s.api.core.v1.PodTemplateSpec"
      description:
        DeploymentSpec is the specification of the desired behavior of
        the Deployment.
    io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector:
      type: object
      properties:
        matchExpressions:
          type: array
          description:
            matchExpressions is a list of label selector requirements.
            The requirements are ANDed.
          items:
            $ref: "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement"
        matchLabels:
          type: object
          additionalProperties:
            type: string
          description:
            "matchLabels is a map of {key,value} pairs. A single {key,value}\
            \ in the matchLabels map is equivalent to an element of matchExpressions,\
            \ whose key field is \"key\", the operator is \"In\", and the values array\
            \ contains only \"value\". The requirements are ANDed."
      description:
        A label selector is a label query over a set of resources. The
        result of matchLabels and matchExpressions are ANDed. An empty label selector
        matches all objects. A null label selector matches no objects.
      x-kubernetes-map-type: atomic
    io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement:
      required:
        - key
        - operator
      type: object
      properties:
        key:
          type: string
          description: key is the label key that the selector applies to.
        operator:
          type: string
          description:
            "operator represents a key's relationship to a set of values.\
            \ Valid operators are In, NotIn, Exists and DoesNotExist."
        values:
          type: array
          description:
            "values is an array of string values. If the operator is In\
            \ or NotIn, the values array must be non-empty. If the operator is Exists\
            \ or DoesNotExist, the values array must be empty. This array is replaced\
            \ during a strategic merge patch."
          items:
            type: string
      description:
        "A label selector requirement is a selector that contains values,\
        \ a key, and an operator that relates the key and values."
    io.k8s.api.apps.v1.DeploymentStrategy:
      type: object
      properties:
        rollingUpdate:
          $ref: "#/components/schemas/io.k8s.api.apps.v1.RollingUpdateDeployment"
        type:
          type: string
          description: |-
            Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.

            Possible enum values:
             - `"Recreate"` Kill all existing pods before creating new ones.
             - `"RollingUpdate"` Replace the old ReplicaSets by new one using rolling update i.e gradually scale down the old ReplicaSets and scale up the new one.
          enum:
            - Recreate
            - RollingUpdate
      description:
        DeploymentStrategy describes how to replace existing pods with
        new ones.
    io.k8s.api.apps.v1.RollingUpdateDeployment:
      type: object
      properties:
        maxSurge:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.util.intstr.IntOrString"
        maxUnavailable:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.util.intstr.IntOrString"
      description: Spec to control the desired behavior of rolling update.
    io.k8s.apimachinery.pkg.util.intstr.IntOrString:
      type: string
      description:
        "IntOrString is a type that can hold an int32 or a string.  When\
        \ used in JSON or YAML marshalling and unmarshalling, it produces or consumes\
        \ the inner type.  This allows you to have, for example, a JSON field that\
        \ can accept a name or number."
      format: int-or-string
    io.k8s.api.core.v1.PodTemplateSpec:
      type: object
      properties:
        metadata:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        spec:
          $ref: "#/components/schemas/io.k8s.api.core.v1.PodSpec"
      description:
        PodTemplateSpec describes the data a pod should have when created
        from a template
    io.k8s.api.core.v1.PodSpec:
      required:
        - containers
      type: object
      properties:
        activeDeadlineSeconds:
          type: integer
          description:
            Optional duration in seconds the pod may be active on the node
            relative to StartTime before the system will actively try to mark it failed
            and kill associated containers. Value must be a positive integer.
          format: int64
        affinity:
          $ref: "#/components/schemas/io.k8s.api.core.v1.Affinity"
        automountServiceAccountToken:
          type: boolean
          description:
            AutomountServiceAccountToken indicates whether a service account
            token should be automatically mounted.
        containers:
          type: array
          description:
            List of containers belonging to the pod. Containers cannot
            currently be added or removed. There must be at least one container in
            a Pod. Cannot be updated.
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.Container"
          x-kubernetes-patch-strategy: merge
          x-kubernetes-patch-merge-key: name
        dnsConfig:
          $ref: "#/components/schemas/io.k8s.api.core.v1.PodDNSConfig"
        dnsPolicy:
          type: string
          description: |-
            Set DNS policy for the pod. Defaults to "ClusterFirst". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.

            Possible enum values:
             - `"ClusterFirst"` indicates that the pod should use cluster DNS first unless hostNetwork is true, if it is available, then fall back on the default (as determined by kubelet) DNS settings.
             - `"ClusterFirstWithHostNet"` indicates that the pod should use cluster DNS first, if it is available, then fall back on the default (as determined by kubelet) DNS settings.
             - `"Default"` indicates that the pod should use the default (as determined by kubelet) DNS settings.
             - `"None"` indicates that the pod should use empty DNS settings. DNS parameters such as nameservers and search paths should be defined via DNSConfig.
          enum:
            - ClusterFirst
            - ClusterFirstWithHostNet
            - Default
            - None
        enableServiceLinks:
          type: boolean
          description:
            "EnableServiceLinks indicates whether information about services\
            \ should be injected into pod's environment variables, matching the syntax\
            \ of Docker links. Optional: Defaults to true."
        ephemeralContainers:
          type: array
          description:
            "List of ephemeral containers run in this pod. Ephemeral containers\
            \ may be run in an existing pod to perform user-initiated actions such\
            \ as debugging. This list cannot be specified when creating a pod, and\
            \ it cannot be modified by updating the pod spec. In order to add an ephemeral\
            \ container to an existing pod, use the pod's ephemeralcontainers subresource."
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.EphemeralContainer"
          x-kubernetes-patch-strategy: merge
          x-kubernetes-patch-merge-key: name
        hostAliases:
          type: array
          description:
            HostAliases is an optional list of hosts and IPs that will
            be injected into the pod's hosts file if specified. This is only valid
            for non-hostNetwork pods.
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.HostAlias"
          x-kubernetes-patch-strategy: merge
          x-kubernetes-patch-merge-key: ip
        hostIPC:
          type: boolean
          description: "Use the host's ipc namespace. Optional: Default to false."
        hostNetwork:
          type: boolean
          description:
            "Host networking requested for this pod. Use the host's network\
            \ namespace. If this option is set, the ports that will be used must be\
            \ specified. Default to false."
        hostPID:
          type: boolean
          description: "Use the host's pid namespace. Optional: Default to false."
        hostUsers:
          type: boolean
          description:
            "Use the host's user namespace. Optional: Default to true.\
            \ If set to true or not present, the pod will be run in the host user\
            \ namespace, useful for when the pod needs a feature only available to\
            \ the host user namespace, such as loading a kernel module with CAP_SYS_MODULE.\
            \ When set to false, a new userns is created for the pod. Setting false\
            \ is useful for mitigating container breakout vulnerabilities even allowing\
            \ users to run their containers as root without actually having root privileges\
            \ on the host. This field is alpha-level and is only honored by servers\
            \ that enable the UserNamespacesSupport feature."
        hostname:
          type: string
          description:
            "Specifies the hostname of the Pod If not specified, the pod's\
            \ hostname will be set to a system-defined value."
        imagePullSecrets:
          type: array
          description:
            "ImagePullSecrets is an optional list of references to secrets\
            \ in the same namespace to use for pulling any of the images used by this\
            \ PodSpec. If specified, these secrets will be passed to individual puller\
            \ implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod"
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.LocalObjectReference"
          x-kubernetes-patch-strategy: merge
          x-kubernetes-patch-merge-key: name
        initContainers:
          type: array
          description:
            "List of initialization containers belonging to the pod. Init\
            \ containers are executed in order prior to containers being started.\
            \ If any init container fails, the pod is considered to have failed and\
            \ is handled according to its restartPolicy. The name for an init container\
            \ or normal container must be unique among all containers. Init containers\
            \ may not have Lifecycle actions, Readiness probes, Liveness probes, or\
            \ Startup probes. The resourceRequirements of an init container are taken\
            \ into account during scheduling by finding the highest request/limit\
            \ for each resource type, and then using the max of of that value or the\
            \ sum of the normal containers. Limits are applied to init containers\
            \ in a similar fashion. Init containers cannot currently be added or removed.\
            \ Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/"
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.Container"
          x-kubernetes-patch-strategy: merge
          x-kubernetes-patch-merge-key: name
        nodeName:
          type: string
          description:
            "NodeName is a request to schedule this pod onto a specific\
            \ node. If it is non-empty, the scheduler simply schedules this pod onto\
            \ that node, assuming that it fits resource requirements."
        nodeSelector:
          type: object
          additionalProperties:
            type: string
          description:
            "NodeSelector is a selector which must be true for the pod\
            \ to fit on a node. Selector which must match a node's labels for the\
            \ pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/"
          x-kubernetes-map-type: atomic
        os:
          $ref: "#/components/schemas/io.k8s.api.core.v1.PodOS"
        overhead:
          type: object
          additionalProperties:
            $ref: "#/components/schemas/io.k8s.apimachinery.pkg.api.resource.Quantity"
          description:
            "Overhead represents the resource overhead associated with\
            \ running a pod for a given RuntimeClass. This field will be autopopulated\
            \ at admission time by the RuntimeClass admission controller. If the RuntimeClass\
            \ admission controller is enabled, overhead must not be set in Pod create\
            \ requests. The RuntimeClass admission controller will reject Pod create\
            \ requests which have the overhead already set. If RuntimeClass is configured\
            \ and selected in the PodSpec, Overhead will be set to the value defined\
            \ in the corresponding RuntimeClass, otherwise it will remain unset and\
            \ treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md"
        preemptionPolicy:
          type: string
          description: |-
            PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset.

            Possible enum values:
             - `"Never"` means that pod never preempts other pods with lower priority.
             - `"PreemptLowerPriority"` means that pod can preempt other pods with lower priority.
          enum:
            - Never
            - PreemptLowerPriority
        priority:
          type: integer
          description:
            "The priority value. Various system components use this field\
            \ to find the priority of the pod. When Priority Admission Controller\
            \ is enabled, it prevents users from setting this field. The admission\
            \ controller populates this field from PriorityClassName. The higher the\
            \ value, the higher the priority."
          format: int32
        priorityClassName:
          type: string
          description:
            "If specified, indicates the pod's priority. \"system-node-critical\"\
            \ and \"system-cluster-critical\" are two special keywords which indicate\
            \ the highest priorities with the former being the highest priority. Any\
            \ other name must be defined by creating a PriorityClass object with that\
            \ name. If not specified, the pod priority will be default or zero if\
            \ there is no default."
        readinessGates:
          type: array
          description:
            "If specified, all readiness gates will be evaluated for pod\
            \ readiness. A pod is ready when all its containers are ready AND all\
            \ conditions specified in the readiness gates have status equal to \"\
            True\" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates"
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.PodReadinessGate"
        resourceClaims:
          type: array
          description: |-
            ResourceClaims defines which ResourceClaims must be allocated and reserved before the Pod is allowed to start. The resources will be made available to those containers which consume them by name.

            This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.

            This field is immutable.
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.PodResourceClaim"
          x-kubernetes-patch-strategy: "merge,retainKeys"
          x-kubernetes-list-type: map
          x-kubernetes-list-map-keys:
            - name
          x-kubernetes-patch-merge-key: name
        restartPolicy:
          type: string
          description: |-
            Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy

            Possible enum values:
             - `"Always"`
             - `"Never"`
             - `"OnFailure"`
          enum:
            - Always
            - Never
            - OnFailure
        runtimeClassName:
          type: string
          description:
            "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io\
            \ group, which should be used to run this pod.  If no RuntimeClass resource\
            \ matches the named class, the pod will not be run. If unset or empty,\
            \ the \"legacy\" RuntimeClass will be used, which is an implicit class\
            \ with an empty definition that uses the default runtime handler. More\
            \ info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class"
        schedulerName:
          type: string
          description:
            "If specified, the pod will be dispatched by specified scheduler.\
            \ If not specified, the pod will be dispatched by default scheduler."
        schedulingGates:
          type: array
          description: |-
            SchedulingGates is an opaque list of values that if specified will block scheduling the pod. If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the scheduler will not attempt to schedule the pod.

            SchedulingGates can only be set at pod creation time, and be removed only afterwards.

            This is a beta feature enabled by the PodSchedulingReadiness feature gate.
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.PodSchedulingGate"
          x-kubernetes-patch-strategy: merge
          x-kubernetes-list-type: map
          x-kubernetes-list-map-keys:
            - name
          x-kubernetes-patch-merge-key: name
        securityContext:
          $ref: "#/components/schemas/io.k8s.api.core.v1.PodSecurityContext"
        serviceAccount:
          type: string
          description:
            "DeprecatedServiceAccount is a depreciated alias for ServiceAccountName.\
            \ Deprecated: Use serviceAccountName instead."
        serviceAccountName:
          type: string
          description:
            "ServiceAccountName is the name of the ServiceAccount to use\
            \ to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/"
        setHostnameAsFQDN:
          type: boolean
          description:
            "If true the pod's hostname will be configured as the pod's\
            \ FQDN, rather than the leaf name (the default). In Linux containers,\
            \ this means setting the FQDN in the hostname field of the kernel (the\
            \ nodename field of struct utsname). In Windows containers, this means\
            \ setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\\
            SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN. If a pod\
            \ does not have FQDN, this has no effect. Default to false."
        shareProcessNamespace:
          type: boolean
          description:
            "Share a single process namespace between all of the containers\
            \ in a pod. When this is set containers will be able to view and signal\
            \ processes from other containers in the same pod, and the first process\
            \ in each container will not be assigned PID 1. HostPID and ShareProcessNamespace\
            \ cannot both be set. Optional: Default to false."
        subdomain:
          type: string
          description:
            "If specified, the fully qualified Pod hostname will be \"\
            <hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>\". If not\
            \ specified, the pod will not have a domainname at all."
        terminationGracePeriodSeconds:
          type: integer
          description:
            "Optional duration in seconds the pod needs to terminate gracefully.\
            \ May be decreased in delete request. Value must be non-negative integer.\
            \ The value zero indicates stop immediately via the kill signal (no opportunity\
            \ to shut down). If this value is nil, the default grace period will be\
            \ used instead. The grace period is the duration in seconds after the\
            \ processes running in the pod are sent a termination signal and the time\
            \ when the processes are forcibly halted with a kill signal. Set this\
            \ value longer than the expected cleanup time for your process. Defaults\
            \ to 30 seconds."
          format: int64
        tolerations:
          type: array
          description: "If specified, the pod's tolerations."
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.Toleration"
        topologySpreadConstraints:
          type: array
          description:
            TopologySpreadConstraints describes how a group of pods ought
            to spread across topology domains. Scheduler will schedule pods in a way
            which abides by the constraints. All topologySpreadConstraints are ANDed.
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.TopologySpreadConstraint"
          x-kubernetes-patch-strategy: merge
          x-kubernetes-list-type: map
          x-kubernetes-list-map-keys:
            - topologyKey
            - whenUnsatisfiable
          x-kubernetes-patch-merge-key: topologyKey
        volumes:
          type: array
          description:
            "List of volumes that can be mounted by containers belonging\
            \ to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes"
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.Volume"
          x-kubernetes-patch-strategy: "merge,retainKeys"
          x-kubernetes-patch-merge-key: name
      description: PodSpec is a description of a pod.
    io.k8s.api.core.v1.Affinity:
      type: object
      properties:
        nodeAffinity:
          $ref: "#/components/schemas/io.k8s.api.core.v1.NodeAffinity"
        podAffinity:
          $ref: "#/components/schemas/io.k8s.api.core.v1.PodAffinity"
        podAntiAffinity:
          $ref: "#/components/schemas/io.k8s.api.core.v1.PodAntiAffinity"
      description: Affinity is a group of affinity scheduling rules.
    io.k8s.api.core.v1.NodeAffinity:
      type: object
      properties:
        preferredDuringSchedulingIgnoredDuringExecution:
          type: array
          description:
            "The scheduler will prefer to schedule pods to nodes that satisfy\
            \ the affinity expressions specified by this field, but it may choose\
            \ a node that violates one or more of the expressions. The node that is\
            \ most preferred is the one with the greatest sum of weights, i.e. for\
            \ each node that meets all of the scheduling requirements (resource request,\
            \ requiredDuringScheduling affinity expressions, etc.), compute a sum\
            \ by iterating through the elements of this field and adding \"weight\"\
            \ to the sum if the node matches the corresponding matchExpressions; the\
            \ node(s) with the highest sum are the most preferred."
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.PreferredSchedulingTerm"
        requiredDuringSchedulingIgnoredDuringExecution:
          $ref: "#/components/schemas/io.k8s.api.core.v1.NodeSelector"
      description: Node affinity is a group of node affinity scheduling rules.
    io.k8s.api.core.v1.PreferredSchedulingTerm:
      required:
        - preference
        - weight
      type: object
      properties:
        preference:
          $ref: "#/components/schemas/io.k8s.api.core.v1.NodeSelectorTerm"
        weight:
          type: integer
          description:
            "Weight associated with matching the corresponding nodeSelectorTerm,\
            \ in the range 1-100."
          format: int32
      description:
        An empty preferred scheduling term matches all objects with implicit
        weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no
        objects (i.e. is also a no-op).
    io.k8s.api.core.v1.NodeSelectorTerm:
      type: object
      properties:
        matchExpressions:
          type: array
          description: A list of node selector requirements by node's labels.
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.NodeSelectorRequirement"
        matchFields:
          type: array
          description: A list of node selector requirements by node's fields.
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.NodeSelectorRequirement"
      description:
        A null or empty node selector term matches no objects. The requirements
        of them are ANDed. The TopologySelectorTerm type implements a subset of the
        NodeSelectorTerm.
      x-kubernetes-map-type: atomic
    io.k8s.api.core.v1.NodeSelectorRequirement:
      required:
        - key
        - operator
      type: object
      properties:
        key:
          type: string
          description: The label key that the selector applies to.
        operator:
          type: string
          description: |-
            Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.

            Possible enum values:
             - `"DoesNotExist"`
             - `"Exists"`
             - `"Gt"`
             - `"In"`
             - `"Lt"`
             - `"NotIn"`
          enum:
            - DoesNotExist
            - Exists
            - Gt
            - In
            - Lt
            - NotIn
        values:
          type: array
          description:
            "An array of string values. If the operator is In or NotIn,\
            \ the values array must be non-empty. If the operator is Exists or DoesNotExist,\
            \ the values array must be empty. If the operator is Gt or Lt, the values\
            \ array must have a single element, which will be interpreted as an integer.\
            \ This array is replaced during a strategic merge patch."
          items:
            type: string
      description:
        "A node selector requirement is a selector that contains values,\
        \ a key, and an operator that relates the key and values."
    io.k8s.api.core.v1.NodeSelector:
      required:
        - nodeSelectorTerms
      type: object
      properties:
        nodeSelectorTerms:
          type: array
          description: Required. A list of node selector terms. The terms are ORed.
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.NodeSelectorTerm"
      description:
        "A node selector represents the union of the results of one or\
        \ more label queries over a set of nodes; that is, it represents the OR of\
        \ the selectors represented by the node selector terms."
      x-kubernetes-map-type: atomic
    io.k8s.api.core.v1.PodAffinity:
      type: object
      properties:
        preferredDuringSchedulingIgnoredDuringExecution:
          type: array
          description:
            "The scheduler will prefer to schedule pods to nodes that satisfy\
            \ the affinity expressions specified by this field, but it may choose\
            \ a node that violates one or more of the expressions. The node that is\
            \ most preferred is the one with the greatest sum of weights, i.e. for\
            \ each node that meets all of the scheduling requirements (resource request,\
            \ requiredDuringScheduling affinity expressions, etc.), compute a sum\
            \ by iterating through the elements of this field and adding \"weight\"\
            \ to the sum if the node has pods which matches the corresponding podAffinityTerm;\
            \ the node(s) with the highest sum are the most preferred."
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.WeightedPodAffinityTerm"
        requiredDuringSchedulingIgnoredDuringExecution:
          type: array
          description:
            "If the affinity requirements specified by this field are not\
            \ met at scheduling time, the pod will not be scheduled onto the node.\
            \ If the affinity requirements specified by this field cease to be met\
            \ at some point during pod execution (e.g. due to a pod label update),\
            \ the system may or may not try to eventually evict the pod from its node.\
            \ When there are multiple elements, the lists of nodes corresponding to\
            \ each podAffinityTerm are intersected, i.e. all terms must be satisfied."
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.PodAffinityTerm"
      description: Pod affinity is a group of inter pod affinity scheduling rules.
    io.k8s.api.core.v1.WeightedPodAffinityTerm:
      required:
        - podAffinityTerm
        - weight
      type: object
      properties:
        podAffinityTerm:
          $ref: "#/components/schemas/io.k8s.api.core.v1.PodAffinityTerm"
        weight:
          type: integer
          description:
            "weight associated with matching the corresponding podAffinityTerm,\
            \ in the range 1-100."
          format: int32
      description:
        The weights of all of the matched WeightedPodAffinityTerm fields
        are added per-node to find the most preferred node(s)
    io.k8s.api.core.v1.PodAffinityTerm:
      required:
        - topologyKey
      type: object
      properties:
        labelSelector:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        matchLabelKeys:
          type: array
          description:
            "MatchLabelKeys is a set of pod label keys to select which\
            \ pods will be taken into consideration. The keys are used to lookup values\
            \ from the incoming pod labels, those key-value labels are merged with\
            \ `LabelSelector` as `key in (value)` to select the group of existing\
            \ pods which pods will be taken into consideration for the incoming pod's\
            \ pod (anti) affinity. Keys that don't exist in the incoming pod labels\
            \ will be ignored. The default value is empty. The same key is forbidden\
            \ to exist in both MatchLabelKeys and LabelSelector. Also, MatchLabelKeys\
            \ cannot be set when LabelSelector isn't set. This is an alpha field and\
            \ requires enabling MatchLabelKeysInPodAffinity feature gate."
          items:
            type: string
          x-kubernetes-list-type: atomic
        mismatchLabelKeys:
          type: array
          description:
            "MismatchLabelKeys is a set of pod label keys to select which\
            \ pods will be taken into consideration. The keys are used to lookup values\
            \ from the incoming pod labels, those key-value labels are merged with\
            \ `LabelSelector` as `key notin (value)` to select the group of existing\
            \ pods which pods will be taken into consideration for the incoming pod's\
            \ pod (anti) affinity. Keys that don't exist in the incoming pod labels\
            \ will be ignored. The default value is empty. The same key is forbidden\
            \ to exist in both MismatchLabelKeys and LabelSelector. Also, MismatchLabelKeys\
            \ cannot be set when LabelSelector isn't set. This is an alpha field and\
            \ requires enabling MatchLabelKeysInPodAffinity feature gate."
          items:
            type: string
          x-kubernetes-list-type: atomic
        namespaceSelector:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        namespaces:
          type: array
          description:
            namespaces specifies a static list of namespace names that
            the term applies to. The term is applied to the union of the namespaces
            listed in this field and the ones selected by namespaceSelector. null
            or empty namespaces list and null namespaceSelector means "this pod's
            namespace".
          items:
            type: string
        topologyKey:
          type: string
          description:
            "This pod should be co-located (affinity) or not co-located\
            \ (anti-affinity) with the pods matching the labelSelector in the specified\
            \ namespaces, where co-located is defined as running on a node whose value\
            \ of the label with key topologyKey matches that of any node on which\
            \ any of the selected pods is running. Empty topologyKey is not allowed."
      description:
        "Defines a set of pods (namely those matching the labelSelector\
        \ relative to the given namespace(s)) that this pod should be co-located (affinity)\
        \ or not co-located (anti-affinity) with, where co-located is defined as running\
        \ on a node whose value of the label with key <topologyKey> matches that of\
        \ any node on which a pod of the set of pods is running"
    io.k8s.api.core.v1.PodAntiAffinity:
      type: object
      properties:
        preferredDuringSchedulingIgnoredDuringExecution:
          type: array
          description:
            "The scheduler will prefer to schedule pods to nodes that satisfy\
            \ the anti-affinity expressions specified by this field, but it may choose\
            \ a node that violates one or more of the expressions. The node that is\
            \ most preferred is the one with the greatest sum of weights, i.e. for\
            \ each node that meets all of the scheduling requirements (resource request,\
            \ requiredDuringScheduling anti-affinity expressions, etc.), compute a\
            \ sum by iterating through the elements of this field and adding \"weight\"\
            \ to the sum if the node has pods which matches the corresponding podAffinityTerm;\
            \ the node(s) with the highest sum are the most preferred."
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.WeightedPodAffinityTerm"
        requiredDuringSchedulingIgnoredDuringExecution:
          type: array
          description:
            "If the anti-affinity requirements specified by this field\
            \ are not met at scheduling time, the pod will not be scheduled onto the\
            \ node. If the anti-affinity requirements specified by this field cease\
            \ to be met at some point during pod execution (e.g. due to a pod label\
            \ update), the system may or may not try to eventually evict the pod from\
            \ its node. When there are multiple elements, the lists of nodes corresponding\
            \ to each podAffinityTerm are intersected, i.e. all terms must be satisfied."
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.PodAffinityTerm"
      description:
        Pod anti affinity is a group of inter pod anti affinity scheduling
        rules.
    io.k8s.api.core.v1.Container:
      required:
        - name
      type: object
      properties:
        args:
          type: array
          description:
            "Arguments to the entrypoint. The container image's CMD is\
            \ used if this is not provided. Variable references $(VAR_NAME) are expanded\
            \ using the container's environment. If a variable cannot be resolved,\
            \ the reference in the input string will be unchanged. Double $$ are reduced\
            \ to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.\
            \ \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped\
            \ references will never be expanded, regardless of whether the variable\
            \ exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell"
          items:
            type: string
        command:
          type: array
          description:
            "Entrypoint array. Not executed within a shell. The container\
            \ image's ENTRYPOINT is used if this is not provided. Variable references\
            \ $(VAR_NAME) are expanded using the container's environment. If a variable\
            \ cannot be resolved, the reference in the input string will be unchanged.\
            \ Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME)\
            \ syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\"\
            . Escaped references will never be expanded, regardless of whether the\
            \ variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell"
          items:
            type: string
        env:
          type: array
          description:
            List of environment variables to set in the container. Cannot
            be updated.
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.EnvVar"
          x-kubernetes-patch-strategy: merge
          x-kubernetes-patch-merge-key: name
        envFrom:
          type: array
          description:
            "List of sources to populate environment variables in the container.\
            \ The keys defined within a source must be a C_IDENTIFIER. All invalid\
            \ keys will be reported as an event when the container is starting. When\
            \ a key exists in multiple sources, the value associated with the last\
            \ source will take precedence. Values defined by an Env with a duplicate\
            \ key will take precedence. Cannot be updated."
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.EnvFromSource"
        image:
          type: string
          description:
            "Container image name. More info: https://kubernetes.io/docs/concepts/containers/images\
            \ This field is optional to allow higher level config management to default\
            \ or override container images in workload controllers like Deployments\
            \ and StatefulSets."
        imagePullPolicy:
          type: string
          description: |-
            Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images

            Possible enum values:
             - `"Always"` means that kubelet always attempts to pull the latest image. Container will fail If the pull fails.
             - `"IfNotPresent"` means that kubelet pulls if the image isn't present on disk. Container will fail if the image isn't present and the pull fails.
             - `"Never"` means that kubelet never pulls an image, but only uses a local image. Container will fail if the image isn't present
          enum:
            - Always
            - IfNotPresent
            - Never
        lifecycle:
          $ref: "#/components/schemas/io.k8s.api.core.v1.Lifecycle"
        livenessProbe:
          $ref: "#/components/schemas/io.k8s.api.core.v1.Probe"
        name:
          type: string
          description:
            Name of the container specified as a DNS_LABEL. Each container
            in a pod must have a unique name (DNS_LABEL). Cannot be updated.
        ports:
          type: array
          description:
            List of ports to expose from the container. Not specifying
            a port here DOES NOT prevent that port from being exposed. Any port which
            is listening on the default "0.0.0.0" address inside a container will
            be accessible from the network. Modifying this array with strategic merge
            patch may corrupt the data. For more information See https://github.com/kubernetes/kubernetes/issues/108255.
            Cannot be updated.
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.ContainerPort"
          x-kubernetes-patch-strategy: merge
          x-kubernetes-list-type: map
          x-kubernetes-list-map-keys:
            - containerPort
            - protocol
          x-kubernetes-patch-merge-key: containerPort
        readinessProbe:
          $ref: "#/components/schemas/io.k8s.api.core.v1.Probe"
        resizePolicy:
          type: array
          description: Resources resize policy for the container.
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.ContainerResizePolicy"
          x-kubernetes-list-type: atomic
        resources:
          $ref: "#/components/schemas/io.k8s.api.core.v1.ResourceRequirements"
        restartPolicy:
          type: string
          description:
            "RestartPolicy defines the restart behavior of individual containers\
            \ in a pod. This field may only be set for init containers, and the only\
            \ allowed value is \"Always\". For non-init containers or when this field\
            \ is not specified, the restart behavior is defined by the Pod's restart\
            \ policy and the container type. Setting the RestartPolicy as \"Always\"\
            \ for the init container will have the following effect: this init container\
            \ will be continually restarted on exit until all regular containers have\
            \ terminated. Once all regular containers have completed, all init containers\
            \ with restartPolicy \"Always\" will be shut down. This lifecycle differs\
            \ from normal init containers and is often referred to as a \"sidecar\"\
            \ container. Although this init container still starts in the init container\
            \ sequence, it does not wait for the container to complete before proceeding\
            \ to the next init container. Instead, the next init container starts\
            \ immediately after this init container is started, or after any startupProbe\
            \ has successfully completed."
        securityContext:
          $ref: "#/components/schemas/io.k8s.api.core.v1.SecurityContext"
        startupProbe:
          $ref: "#/components/schemas/io.k8s.api.core.v1.Probe"
        stdin:
          type: boolean
          description:
            "Whether this container should allocate a buffer for stdin\
            \ in the container runtime. If this is not set, reads from stdin in the\
            \ container will always result in EOF. Default is false."
        stdinOnce:
          type: boolean
          description:
            "Whether the container runtime should close the stdin channel\
            \ after it has been opened by a single attach. When stdin is true the\
            \ stdin stream will remain open across multiple attach sessions. If stdinOnce\
            \ is set to true, stdin is opened on container start, is empty until the\
            \ first client attaches to stdin, and then remains open and accepts data\
            \ until the client disconnects, at which time stdin is closed and remains\
            \ closed until the container is restarted. If this flag is false, a container\
            \ processes that reads from stdin will never receive an EOF. Default is\
            \ false"
        terminationMessagePath:
          type: string
          description:
            "Optional: Path at which the file to which the container's\
            \ termination message will be written is mounted into the container's\
            \ filesystem. Message written is intended to be brief final status, such\
            \ as an assertion failure message. Will be truncated by the node if greater\
            \ than 4096 bytes. The total message length across all containers will\
            \ be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated."
        terminationMessagePolicy:
          type: string
          description: |-
            Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.

            Possible enum values:
             - `"FallbackToLogsOnError"` will read the most recent contents of the container logs for the container status message when the container exits with an error and the terminationMessagePath has no contents.
             - `"File"` is the default behavior and will set the container status message to the contents of the container's terminationMessagePath when the container exits.
          enum:
            - FallbackToLogsOnError
            - File
        tty:
          type: boolean
          description:
            "Whether this container should allocate a TTY for itself, also\
            \ requires 'stdin' to be true. Default is false."
        volumeDevices:
          type: array
          description:
            volumeDevices is the list of block devices to be used by the
            container.
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.VolumeDevice"
          x-kubernetes-patch-strategy: merge
          x-kubernetes-patch-merge-key: devicePath
        volumeMounts:
          type: array
          description:
            Pod volumes to mount into the container's filesystem. Cannot
            be updated.
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.VolumeMount"
          x-kubernetes-patch-strategy: merge
          x-kubernetes-patch-merge-key: mountPath
        workingDir:
          type: string
          description:
            "Container's working directory. If not specified, the container\
            \ runtime's default will be used, which might be configured in the container\
            \ image. Cannot be updated."
      description: A single application container that you want to run within a pod.
    io.k8s.api.core.v1.EnvVar:
      required:
        - name
      type: object
      properties:
        name:
          type: string
          description: Name of the environment variable. Must be a C_IDENTIFIER.
        value:
          type: string
          description:
            "Variable references $(VAR_NAME) are expanded using the previously\
            \ defined environment variables in the container and any service environment\
            \ variables. If a variable cannot be resolved, the reference in the input\
            \ string will be unchanged. Double $$ are reduced to a single $, which\
            \ allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will\
            \ produce the string literal \"$(VAR_NAME)\". Escaped references will\
            \ never be expanded, regardless of whether the variable exists or not.\
            \ Defaults to \"\"."
        valueFrom:
          $ref: "#/components/schemas/io.k8s.api.core.v1.EnvVarSource"
      description: EnvVar represents an environment variable present in a Container.
    io.k8s.api.core.v1.EnvVarSource:
      type: object
      properties:
        configMapKeyRef:
          $ref: "#/components/schemas/io.k8s.api.core.v1.ConfigMapKeySelector"
        fieldRef:
          $ref: "#/components/schemas/io.k8s.api.core.v1.ObjectFieldSelector"
        resourceFieldRef:
          $ref: "#/components/schemas/io.k8s.api.core.v1.ResourceFieldSelector"
        secretKeyRef:
          $ref: "#/components/schemas/io.k8s.api.core.v1.SecretKeySelector"
      description: EnvVarSource represents a source for the value of an EnvVar.
    io.k8s.api.core.v1.ConfigMapKeySelector:
      required:
        - key
      type: object
      properties:
        key:
          type: string
          description: The key to select.
        name:
          type: string
          description: "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"
        optional:
          type: boolean
          description: Specify whether the ConfigMap or its key must be defined
      description: Selects a key from a ConfigMap.
      x-kubernetes-map-type: atomic
    io.k8s.api.core.v1.ObjectFieldSelector:
      required:
        - fieldPath
      type: object
      properties:
        apiVersion:
          type: string
          description:
            "Version of the schema the FieldPath is written in terms of,\
            \ defaults to \"v1\"."
        fieldPath:
          type: string
          description: Path of the field to select in the specified API version.
      description: ObjectFieldSelector selects an APIVersioned field of an object.
      x-kubernetes-map-type: atomic
    io.k8s.api.core.v1.ResourceFieldSelector:
      required:
        - resource
      type: object
      properties:
        containerName:
          type: string
          description: "Container name: required for volumes, optional for env vars"
        divisor:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.api.resource.Quantity"
        resource:
          type: string
          description: "Required: resource to select"
      description:
        "ResourceFieldSelector represents container resources (cpu, memory)\
        \ and their output format"
      x-kubernetes-map-type: atomic
    io.k8s.apimachinery.pkg.api.resource.Quantity:
      type: string
      description:
        "Quantity is a fixed-point representation of a number. It provides\
        \ convenient marshaling/unmarshaling in JSON and YAML, in addition to String()\
        \ and AsInt64() accessors.\n\nThe serialization format is:\n\n``` <quantity>\
        \        ::= <signedNumber><suffix>\n\n\t(Note that <suffix> may be empty,\
        \ from the \"\" case in <decimalSI>.)\n\n<digit>           ::= 0 | 1 | ...\
        \ | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::=\
        \ <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::=\
        \ \"+\" | \"-\" <signedNumber>    ::= <number> | <sign><number> <suffix> \
        \         ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>    \
        \    ::= Ki | Mi | Gi | Ti | Pi | Ei\n\n\t(International System of units;\
        \ See: http://physics.nist.gov/cuu/Units/binary.html)\n\n<decimalSI>     \
        \  ::= m | \"\" | k | M | G | T | P | E\n\n\t(Note that 1024 = 1Ki but 1000\
        \ = 1k; I didn't choose the capitalization.)\n\n<decimalExponent> ::= \"e\"\
        \ <signedNumber> | \"E\" <signedNumber> ```\n\nNo matter which of the three\
        \ exponent forms is used, no quantity may represent a number greater than\
        \ 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers\
        \ larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded\
        \ up to 1m.) This may be extended in the future if we require larger or smaller\
        \ quantities.\n\nWhen a Quantity is parsed from a string, it will remember\
        \ the type of suffix it had, and will use the same type again when it is serialized.\n\
        \nBefore serializing, Quantity will be put in \"canonical form\". This means\
        \ that Exponent/suffix will be adjusted up or down (with a corresponding increase\
        \ or decrease in Mantissa) such that:\n\n- No precision is lost - No fractional\
        \ digits will be emitted - The exponent (or suffix) is as large as possible.\n\
        \nThe sign will be omitted unless the number is negative.\n\nExamples:\n\n\
        - 1.5 will be serialized as \"1500m\" - 1.5Gi will be serialized as \"1536Mi\"\
        \n\nNote that the quantity will NEVER be internally represented by a floating\
        \ point number. That is the whole point of this exercise.\n\nNon-canonical\
        \ values will still parse as long as they are well formed, but will be re-emitted\
        \ in their canonical form. (So always use canonical form, or don't diff.)\n\
        \nThis format is intended to make it difficult to use these numbers without\
        \ writing some sort of special handling code in the hopes that that will cause\
        \ implementors to also use a fixed point implementation."
    io.k8s.api.core.v1.SecretKeySelector:
      required:
        - key
      type: object
      properties:
        key:
          type: string
          description:
            The key of the secret to select from.  Must be a valid secret
            key.
        name:
          type: string
          description: "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"
        optional:
          type: boolean
          description: Specify whether the Secret or its key must be defined
      description: SecretKeySelector selects a key of a Secret.
      x-kubernetes-map-type: atomic
    io.k8s.api.core.v1.EnvFromSource:
      type: object
      properties:
        configMapRef:
          $ref: "#/components/schemas/io.k8s.api.core.v1.ConfigMapEnvSource"
        prefix:
          type: string
          description:
            An optional identifier to prepend to each key in the ConfigMap.
            Must be a C_IDENTIFIER.
        secretRef:
          $ref: "#/components/schemas/io.k8s.api.core.v1.SecretEnvSource"
      description: EnvFromSource represents the source of a set of ConfigMaps
    io.k8s.api.core.v1.ConfigMapEnvSource:
      type: object
      properties:
        name:
          type: string
          description: "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"
        optional:
          type: boolean
          description: Specify whether the ConfigMap must be defined
      description: |-
        ConfigMapEnvSource selects a ConfigMap to populate the environment variables with.

        The contents of the target ConfigMap's Data field will represent the key-value pairs as environment variables.
    io.k8s.api.core.v1.SecretEnvSource:
      type: object
      properties:
        name:
          type: string
          description: "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"
        optional:
          type: boolean
          description: Specify whether the Secret must be defined
      description: |-
        SecretEnvSource selects a Secret to populate the environment variables with.

        The contents of the target Secret's Data field will represent the key-value pairs as environment variables.
    io.k8s.api.core.v1.Lifecycle:
      type: object
      properties:
        postStart:
          $ref: "#/components/schemas/io.k8s.api.core.v1.LifecycleHandler"
        preStop:
          $ref: "#/components/schemas/io.k8s.api.core.v1.LifecycleHandler"
      description:
        "Lifecycle describes actions that the management system should\
        \ take in response to container lifecycle events. For the PostStart and PreStop\
        \ lifecycle handlers, management of the container blocks until the action\
        \ is complete, unless the container process fails, in which case the handler\
        \ is aborted."
    io.k8s.api.core.v1.LifecycleHandler:
      type: object
      properties:
        exec:
          $ref: "#/components/schemas/io.k8s.api.core.v1.ExecAction"
        httpGet:
          $ref: "#/components/schemas/io.k8s.api.core.v1.HTTPGetAction"
        sleep:
          $ref: "#/components/schemas/io.k8s.api.core.v1.SleepAction"
        tcpSocket:
          $ref: "#/components/schemas/io.k8s.api.core.v1.TCPSocketAction"
      description:
        "LifecycleHandler defines a specific action that should be taken\
        \ in a lifecycle hook. One and only one of the fields, except TCPSocket must\
        \ be specified."
    io.k8s.api.core.v1.ExecAction:
      type: object
      properties:
        command:
          type: array
          description:
            "Command is the command line to execute inside the container,\
            \ the working directory for the command  is root ('/') in the container's\
            \ filesystem. The command is simply exec'd, it is not run inside a shell,\
            \ so traditional shell instructions ('|', etc) won't work. To use a shell,\
            \ you need to explicitly call out to that shell. Exit status of 0 is treated\
            \ as live/healthy and non-zero is unhealthy."
          items:
            type: string
      description: ExecAction describes a "run in container" action.
    io.k8s.api.core.v1.HTTPGetAction:
      required:
        - port
      type: object
      properties:
        host:
          type: string
          description:
            "Host name to connect to, defaults to the pod IP. You probably\
            \ want to set \"Host\" in httpHeaders instead."
        httpHeaders:
          type: array
          description:
            Custom headers to set in the request. HTTP allows repeated
            headers.
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.HTTPHeader"
        path:
          type: string
          description: Path to access on the HTTP server.
        port:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.util.intstr.IntOrString"
        scheme:
          type: string
          description: |-
            Scheme to use for connecting to the host. Defaults to HTTP.

            Possible enum values:
             - `"HTTP"` means that the scheme used will be http://
             - `"HTTPS"` means that the scheme used will be https://
          enum:
            - HTTP
            - HTTPS
      description: HTTPGetAction describes an action based on HTTP Get requests.
    io.k8s.api.core.v1.HTTPHeader:
      required:
        - name
        - value
      type: object
      properties:
        name:
          type: string
          description:
            "The header field name. This will be canonicalized upon output,\
            \ so case-variant names will be understood as the same header."
        value:
          type: string
          description: The header field value
      description: HTTPHeader describes a custom header to be used in HTTP probes
    io.k8s.api.core.v1.SleepAction:
      required:
        - seconds
      type: object
      properties:
        seconds:
          type: integer
          description: Seconds is the number of seconds to sleep.
          format: int64
      description: SleepAction describes a "sleep" action.
    io.k8s.api.core.v1.TCPSocketAction:
      required:
        - port
      type: object
      properties:
        host:
          type: string
          description: "Optional: Host name to connect to, defaults to the pod IP."
        port:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.util.intstr.IntOrString"
      description: TCPSocketAction describes an action based on opening a socket
    io.k8s.api.core.v1.Probe:
      type: object
      properties:
        exec:
          $ref: "#/components/schemas/io.k8s.api.core.v1.ExecAction"
        failureThreshold:
          type: integer
          description:
            Minimum consecutive failures for the probe to be considered
            failed after having succeeded. Defaults to 3. Minimum value is 1.
          format: int32
        grpc:
          $ref: "#/components/schemas/io.k8s.api.core.v1.GRPCAction"
        httpGet:
          $ref: "#/components/schemas/io.k8s.api.core.v1.HTTPGetAction"
        initialDelaySeconds:
          type: integer
          description:
            "Number of seconds after the container has started before liveness\
            \ probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes"
          format: int32
        periodSeconds:
          type: integer
          description:
            How often (in seconds) to perform the probe. Default to 10
            seconds. Minimum value is 1.
          format: int32
        successThreshold:
          type: integer
          description:
            Minimum consecutive successes for the probe to be considered
            successful after having failed. Defaults to 1. Must be 1 for liveness
            and startup. Minimum value is 1.
          format: int32
        tcpSocket:
          $ref: "#/components/schemas/io.k8s.api.core.v1.TCPSocketAction"
        terminationGracePeriodSeconds:
          type: integer
          description:
            "Optional duration in seconds the pod needs to terminate gracefully\
            \ upon probe failure. The grace period is the duration in seconds after\
            \ the processes running in the pod are sent a termination signal and the\
            \ time when the processes are forcibly halted with a kill signal. Set\
            \ this value longer than the expected cleanup time for your process. If\
            \ this value is nil, the pod's terminationGracePeriodSeconds will be used.\
            \ Otherwise, this value overrides the value provided by the pod spec.\
            \ Value must be non-negative integer. The value zero indicates stop immediately\
            \ via the kill signal (no opportunity to shut down). This is a beta field\
            \ and requires enabling ProbeTerminationGracePeriod feature gate. Minimum\
            \ value is 1. spec.terminationGracePeriodSeconds is used if unset."
          format: int64
        timeoutSeconds:
          type: integer
          description:
            "Number of seconds after which the probe times out. Defaults\
            \ to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes"
          format: int32
      description:
        Probe describes a health check to be performed against a container
        to determine whether it is alive or ready to receive traffic.
    io.k8s.api.core.v1.GRPCAction:
      required:
        - port
      type: object
      properties:
        port:
          type: integer
          description:
            Port number of the gRPC service. Number must be in the range
            1 to 65535.
          format: int32
        service:
          type: string
          description: |-
            Service is the name of the service to place in the gRPC HealthCheckRequest (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).

            If this is not specified, the default behavior is defined by gRPC.
    io.k8s.api.core.v1.ContainerPort:
      required:
        - containerPort
      type: object
      properties:
        containerPort:
          type: integer
          description:
            "Number of port to expose on the pod's IP address. This must\
            \ be a valid port number, 0 < x < 65536."
          format: int32
        hostIP:
          type: string
          description: What host IP to bind the external port to.
        hostPort:
          type: integer
          description:
            "Number of port to expose on the host. If specified, this must\
            \ be a valid port number, 0 < x < 65536. If HostNetwork is specified,\
            \ this must match ContainerPort. Most containers do not need this."
          format: int32
        name:
          type: string
          description:
            "If specified, this must be an IANA_SVC_NAME and unique within\
            \ the pod. Each named port in a pod must have a unique name. Name for\
            \ the port that can be referred to by services."
        protocol:
          type: string
          description: |-
            Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".

            Possible enum values:
             - `"SCTP"` is the SCTP protocol.
             - `"TCP"` is the TCP protocol.
             - `"UDP"` is the UDP protocol.
          enum:
            - SCTP
            - TCP
            - UDP
      description: ContainerPort represents a network port in a single container.
    io.k8s.api.core.v1.ContainerResizePolicy:
      required:
        - resourceName
        - restartPolicy
      type: object
      properties:
        resourceName:
          type: string
          description:
            "Name of the resource to which this resource resize policy\
            \ applies. Supported values: cpu, memory."
        restartPolicy:
          type: string
          description:
            "Restart policy to apply when specified resource is resized.\
            \ If not specified, it defaults to NotRequired."
      description:
        ContainerResizePolicy represents resource resize policy for the
        container.
    io.k8s.api.core.v1.ResourceRequirements:
      type: object
      properties:
        claims:
          type: array
          description: |-
            Claims lists the names of resources, defined in spec.resourceClaims, that are used by this container.

            This is an alpha field and requires enabling the DynamicResourceAllocation feature gate.

            This field is immutable. It can only be set for containers.
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.ResourceClaim"
          x-kubernetes-list-type: map
          x-kubernetes-list-map-keys:
            - name
        limits:
          type: object
          additionalProperties:
            $ref: "#/components/schemas/io.k8s.apimachinery.pkg.api.resource.Quantity"
          description:
            "Limits describes the maximum amount of compute resources allowed.\
            \ More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/"
        requests:
          type: object
          additionalProperties:
            $ref: "#/components/schemas/io.k8s.apimachinery.pkg.api.resource.Quantity"
          description:
            "Requests describes the minimum amount of compute resources\
            \ required. If Requests is omitted for a container, it defaults to Limits\
            \ if that is explicitly specified, otherwise to an implementation-defined\
            \ value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/"
      description: ResourceRequirements describes the compute resource requirements.
    io.k8s.api.core.v1.ResourceClaim:
      required:
        - name
      type: object
      properties:
        name:
          type: string
          description:
            Name must match the name of one entry in pod.spec.resourceClaims
            of the Pod where this field is used. It makes that resource available
            inside a container.
      description: ResourceClaim references one entry in PodSpec.ResourceClaims.
    io.k8s.api.core.v1.SecurityContext:
      type: object
      properties:
        allowPrivilegeEscalation:
          type: boolean
          description:
            "AllowPrivilegeEscalation controls whether a process can gain\
            \ more privileges than its parent process. This bool directly controls\
            \ if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation\
            \ is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN\
            \ Note that this field cannot be set when spec.os.name is windows."
        capabilities:
          $ref: "#/components/schemas/io.k8s.api.core.v1.Capabilities"
        privileged:
          type: boolean
          description:
            Run container in privileged mode. Processes in privileged containers
            are essentially equivalent to root on the host. Defaults to false. Note
            that this field cannot be set when spec.os.name is windows.
        procMount:
          type: string
          description: |-
            procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled. Note that this field cannot be set when spec.os.name is windows.

            Possible enum values:
             - `"Default"` uses the container runtime defaults for readonly and masked paths for /proc. Most container runtimes mask certain paths in /proc to avoid accidental security exposure of special devices or information.
             - `"Unmasked"` bypasses the default masking behavior of the container runtime and ensures the newly created /proc the container stays in tact with no modifications.
          enum:
            - Default
            - Unmasked
        readOnlyRootFilesystem:
          type: boolean
          description:
            Whether this container has a read-only root filesystem. Default
            is false. Note that this field cannot be set when spec.os.name is windows.
        runAsGroup:
          type: integer
          description:
            "The GID to run the entrypoint of the container process. Uses\
            \ runtime default if unset. May also be set in PodSecurityContext.  If\
            \ set in both SecurityContext and PodSecurityContext, the value specified\
            \ in SecurityContext takes precedence. Note that this field cannot be\
            \ set when spec.os.name is windows."
          format: int64
        runAsNonRoot:
          type: boolean
          description:
            "Indicates that the container must run as a non-root user.\
            \ If true, the Kubelet will validate the image at runtime to ensure that\
            \ it does not run as UID 0 (root) and fail to start the container if it\
            \ does. If unset or false, no such validation will be performed. May also\
            \ be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext,\
            \ the value specified in SecurityContext takes precedence."
        runAsUser:
          type: integer
          description:
            "The UID to run the entrypoint of the container process. Defaults\
            \ to user specified in image metadata if unspecified. May also be set\
            \ in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext,\
            \ the value specified in SecurityContext takes precedence. Note that this\
            \ field cannot be set when spec.os.name is windows."
          format: int64
        seLinuxOptions:
          $ref: "#/components/schemas/io.k8s.api.core.v1.SELinuxOptions"
        seccompProfile:
          $ref: "#/components/schemas/io.k8s.api.core.v1.SeccompProfile"
        windowsOptions:
          $ref: "#/components/schemas/io.k8s.api.core.v1.WindowsSecurityContextOptions"
      description:
        "SecurityContext holds security configuration that will be applied\
        \ to a container. Some fields are present in both SecurityContext and PodSecurityContext.\
        \  When both are set, the values in SecurityContext take precedence."
    io.k8s.api.core.v1.Capabilities:
      type: object
      properties:
        add:
          type: array
          description: Added capabilities
          items:
            type: string
        drop:
          type: array
          description: Removed capabilities
          items:
            type: string
      description: Adds and removes POSIX capabilities from running containers.
    io.k8s.api.core.v1.SELinuxOptions:
      type: object
      properties:
        level:
          type: string
          description: Level is SELinux level label that applies to the container.
        role:
          type: string
          description: Role is a SELinux role label that applies to the container.
        type:
          type: string
          description: Type is a SELinux type label that applies to the container.
        user:
          type: string
          description: User is a SELinux user label that applies to the container.
      description: SELinuxOptions are the labels to be applied to the container
    io.k8s.api.core.v1.SeccompProfile:
      required:
        - type
      type: object
      properties:
        localhostProfile:
          type: string
          description:
            "localhostProfile indicates a profile defined in a file on\
            \ the node should be used. The profile must be preconfigured on the node\
            \ to work. Must be a descending path, relative to the kubelet's configured\
            \ seccomp profile location. Must be set if type is \"Localhost\". Must\
            \ NOT be set for any other type."
        type:
          type: string
          description: |-
            type indicates which kind of seccomp profile will be applied. Valid options are:

            Localhost - a profile defined in a file on the node should be used. RuntimeDefault - the container runtime default profile should be used. Unconfined - no profile should be applied.

            Possible enum values:
             - `"Localhost"` indicates a profile defined in a file on the node should be used. The file's location relative to <kubelet-root-dir>/seccomp.
             - `"RuntimeDefault"` represents the default container runtime seccomp profile.
             - `"Unconfined"` indicates no seccomp profile is applied (A.K.A. unconfined).
          enum:
            - Localhost
            - RuntimeDefault
            - Unconfined
      description:
        SeccompProfile defines a pod/container's seccomp profile settings.
        Only one profile source may be set.
      x-kubernetes-unions:
        - discriminator: type
          fields-to-discriminateBy:
            localhostProfile: LocalhostProfile
    io.k8s.api.core.v1.WindowsSecurityContextOptions:
      type: object
      properties:
        gmsaCredentialSpec:
          type: string
          description:
            GMSACredentialSpec is where the GMSA admission webhook (https://github.com/kubernetes-sigs/windows-gmsa)
            inlines the contents of the GMSA credential spec named by the GMSACredentialSpecName
            field.
        gmsaCredentialSpecName:
          type: string
          description:
            GMSACredentialSpecName is the name of the GMSA credential spec
            to use.
        hostProcess:
          type: boolean
          description:
            "HostProcess determines if a container should be run as a 'Host\
            \ Process' container. All of a Pod's containers must have the same effective\
            \ HostProcess value (it is not allowed to have a mix of HostProcess containers\
            \ and non-HostProcess containers). In addition, if HostProcess is true\
            \ then HostNetwork must also be set to true."
        runAsUserName:
          type: string
          description:
            "The UserName in Windows to run the entrypoint of the container\
            \ process. Defaults to the user specified in image metadata if unspecified.\
            \ May also be set in PodSecurityContext. If set in both SecurityContext\
            \ and PodSecurityContext, the value specified in SecurityContext takes\
            \ precedence."
      description:
        WindowsSecurityContextOptions contain Windows-specific options
        and credentials.
    io.k8s.api.core.v1.VolumeDevice:
      required:
        - devicePath
        - name
      type: object
      properties:
        devicePath:
          type: string
          description:
            devicePath is the path inside of the container that the device
            will be mapped to.
        name:
          type: string
          description:
            name must match the name of a persistentVolumeClaim in the
            pod
      description:
        volumeDevice describes a mapping of a raw block device within a
        container.
    io.k8s.api.core.v1.VolumeMount:
      required:
        - mountPath
        - name
      type: object
      properties:
        mountPath:
          type: string
          description:
            Path within the container at which the volume should be mounted.  Must
            not contain ':'.
        mountPropagation:
          type: string
          description: |-
            mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.

            Possible enum values:
             - `"Bidirectional"` means that the volume in a container will receive new mounts from the host or other containers, and its own mounts will be propagated from the container to the host or other containers. Note that this mode is recursively applied to all mounts in the volume ("rshared" in Linux terminology).
             - `"HostToContainer"` means that the volume in a container will receive new mounts from the host or other containers, but filesystems mounted inside the container won't be propagated to the host or other containers. Note that this mode is recursively applied to all mounts in the volume ("rslave" in Linux terminology).
             - `"None"` means that the volume in a container will not receive new mounts from the host or other containers, and filesystems mounted inside the container won't be propagated to the host or other containers. Note that this mode corresponds to "private" in Linux terminology.
          enum:
            - Bidirectional
            - HostToContainer
            - None
        name:
          type: string
          description: This must match the Name of a Volume.
        readOnly:
          type: boolean
          description:
            "Mounted read-only if true, read-write otherwise (false or\
            \ unspecified). Defaults to false."
        subPath:
          type: string
          description:
            Path within the volume from which the container's volume should
            be mounted. Defaults to "" (volume's root).
        subPathExpr:
          type: string
          description:
            Expanded path within the volume from which the container's
            volume should be mounted. Behaves similarly to SubPath but environment
            variable references $(VAR_NAME) are expanded using the container's environment.
            Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive.
      description: VolumeMount describes a mounting of a Volume within a container.
    io.k8s.api.core.v1.PodDNSConfig:
      type: object
      properties:
        nameservers:
          type: array
          description:
            A list of DNS name server IP addresses. This will be appended
            to the base nameservers generated from DNSPolicy. Duplicated nameservers
            will be removed.
          items:
            type: string
        options:
          type: array
          description:
            A list of DNS resolver options. This will be merged with the
            base options generated from DNSPolicy. Duplicated entries will be removed.
            Resolution options given in Options will override those that appear in
            the base DNSPolicy.
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.PodDNSConfigOption"
        searches:
          type: array
          description:
            A list of DNS search domains for host-name lookup. This will
            be appended to the base search paths generated from DNSPolicy. Duplicated
            search paths will be removed.
          items:
            type: string
      description:
        PodDNSConfig defines the DNS parameters of a pod in addition to
        those generated from DNSPolicy.
    io.k8s.api.core.v1.PodDNSConfigOption:
      type: object
      properties:
        name:
          type: string
          description: Required.
        value:
          type: string
      description: PodDNSConfigOption defines DNS resolver options of a pod.
    io.k8s.api.core.v1.EphemeralContainer:
      required:
        - name
      type: object
      properties:
        args:
          type: array
          description:
            "Arguments to the entrypoint. The image's CMD is used if this\
            \ is not provided. Variable references $(VAR_NAME) are expanded using\
            \ the container's environment. If a variable cannot be resolved, the reference\
            \ in the input string will be unchanged. Double $$ are reduced to a single\
            \ $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\"\
            \ will produce the string literal \"$(VAR_NAME)\". Escaped references\
            \ will never be expanded, regardless of whether the variable exists or\
            \ not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell"
          items:
            type: string
        command:
          type: array
          description:
            "Entrypoint array. Not executed within a shell. The image's\
            \ ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME)\
            \ are expanded using the container's environment. If a variable cannot\
            \ be resolved, the reference in the input string will be unchanged. Double\
            \ $$ are reduced to a single $, which allows for escaping the $(VAR_NAME)\
            \ syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\"\
            . Escaped references will never be expanded, regardless of whether the\
            \ variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell"
          items:
            type: string
        env:
          type: array
          description:
            List of environment variables to set in the container. Cannot
            be updated.
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.EnvVar"
          x-kubernetes-patch-strategy: merge
          x-kubernetes-patch-merge-key: name
        envFrom:
          type: array
          description:
            "List of sources to populate environment variables in the container.\
            \ The keys defined within a source must be a C_IDENTIFIER. All invalid\
            \ keys will be reported as an event when the container is starting. When\
            \ a key exists in multiple sources, the value associated with the last\
            \ source will take precedence. Values defined by an Env with a duplicate\
            \ key will take precedence. Cannot be updated."
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.EnvFromSource"
        image:
          type: string
          description: "Container image name. More info: https://kubernetes.io/docs/concepts/containers/images"
        imagePullPolicy:
          type: string
          description: |-
            Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images

            Possible enum values:
             - `"Always"` means that kubelet always attempts to pull the latest image. Container will fail If the pull fails.
             - `"IfNotPresent"` means that kubelet pulls if the image isn't present on disk. Container will fail if the image isn't present and the pull fails.
             - `"Never"` means that kubelet never pulls an image, but only uses a local image. Container will fail if the image isn't present
          enum:
            - Always
            - IfNotPresent
            - Never
        lifecycle:
          $ref: "#/components/schemas/io.k8s.api.core.v1.Lifecycle"
        livenessProbe:
          $ref: "#/components/schemas/io.k8s.api.core.v1.Probe"
        name:
          type: string
          description:
            "Name of the ephemeral container specified as a DNS_LABEL.\
            \ This name must be unique among all containers, init containers and ephemeral\
            \ containers."
        ports:
          type: array
          description: Ports are not allowed for ephemeral containers.
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.ContainerPort"
          x-kubernetes-patch-strategy: merge
          x-kubernetes-list-type: map
          x-kubernetes-list-map-keys:
            - containerPort
            - protocol
          x-kubernetes-patch-merge-key: containerPort
        readinessProbe:
          $ref: "#/components/schemas/io.k8s.api.core.v1.Probe"
        resizePolicy:
          type: array
          description: Resources resize policy for the container.
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.ContainerResizePolicy"
          x-kubernetes-list-type: atomic
        resources:
          $ref: "#/components/schemas/io.k8s.api.core.v1.ResourceRequirements"
        restartPolicy:
          type: string
          description:
            Restart policy for the container to manage the restart behavior
            of each container within a pod. This may only be set for init containers.
            You cannot set this field on ephemeral containers.
        securityContext:
          $ref: "#/components/schemas/io.k8s.api.core.v1.SecurityContext"
        startupProbe:
          $ref: "#/components/schemas/io.k8s.api.core.v1.Probe"
        stdin:
          type: boolean
          description:
            "Whether this container should allocate a buffer for stdin\
            \ in the container runtime. If this is not set, reads from stdin in the\
            \ container will always result in EOF. Default is false."
        stdinOnce:
          type: boolean
          description:
            "Whether the container runtime should close the stdin channel\
            \ after it has been opened by a single attach. When stdin is true the\
            \ stdin stream will remain open across multiple attach sessions. If stdinOnce\
            \ is set to true, stdin is opened on container start, is empty until the\
            \ first client attaches to stdin, and then remains open and accepts data\
            \ until the client disconnects, at which time stdin is closed and remains\
            \ closed until the container is restarted. If this flag is false, a container\
            \ processes that reads from stdin will never receive an EOF. Default is\
            \ false"
        targetContainerName:
          type: string
          description: |-
            If set, the name of the container from PodSpec that this ephemeral container targets. The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container. If not set then the ephemeral container uses the namespaces configured in the Pod spec.

            The container runtime must implement support for this feature. If the runtime does not support namespace targeting then the result of setting this field is undefined.
        terminationMessagePath:
          type: string
          description:
            "Optional: Path at which the file to which the container's\
            \ termination message will be written is mounted into the container's\
            \ filesystem. Message written is intended to be brief final status, such\
            \ as an assertion failure message. Will be truncated by the node if greater\
            \ than 4096 bytes. The total message length across all containers will\
            \ be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated."
        terminationMessagePolicy:
          type: string
          description: |-
            Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.

            Possible enum values:
             - `"FallbackToLogsOnError"` will read the most recent contents of the container logs for the container status message when the container exits with an error and the terminationMessagePath has no contents.
             - `"File"` is the default behavior and will set the container status message to the contents of the container's terminationMessagePath when the container exits.
          enum:
            - FallbackToLogsOnError
            - File
        tty:
          type: boolean
          description:
            "Whether this container should allocate a TTY for itself, also\
            \ requires 'stdin' to be true. Default is false."
        volumeDevices:
          type: array
          description:
            volumeDevices is the list of block devices to be used by the
            container.
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.VolumeDevice"
          x-kubernetes-patch-strategy: merge
          x-kubernetes-patch-merge-key: devicePath
        volumeMounts:
          type: array
          description:
            Pod volumes to mount into the container's filesystem. Subpath
            mounts are not allowed for ephemeral containers. Cannot be updated.
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.VolumeMount"
          x-kubernetes-patch-strategy: merge
          x-kubernetes-patch-merge-key: mountPath
        workingDir:
          type: string
          description:
            "Container's working directory. If not specified, the container\
            \ runtime's default will be used, which might be configured in the container\
            \ image. Cannot be updated."
      description: |-
        An EphemeralContainer is a temporary container that you may add to an existing Pod for user-initiated activities such as debugging. Ephemeral containers have no resource or scheduling guarantees, and they will not be restarted when they exit or when a Pod is removed or restarted. The kubelet may evict a Pod if an ephemeral container causes the Pod to exceed its resource allocation.

        To add an ephemeral container, use the ephemeralcontainers subresource of an existing Pod. Ephemeral containers may not be removed or restarted.
    io.k8s.api.core.v1.HostAlias:
      type: object
      properties:
        hostnames:
          type: array
          description: Hostnames for the above IP address.
          items:
            type: string
        ip:
          type: string
          description: IP address of the host file entry.
      description:
        HostAlias holds the mapping between IP and hostnames that will
        be injected as an entry in the pod's hosts file.
    io.k8s.api.core.v1.LocalObjectReference:
      type: object
      properties:
        name:
          type: string
          description: "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"
      description:
        LocalObjectReference contains enough information to let you locate
        the referenced object inside the same namespace.
      x-kubernetes-map-type: atomic
    io.k8s.api.core.v1.PodOS:
      required:
        - name
      type: object
      properties:
        name:
          type: string
          description:
            "Name is the name of the operating system. The currently supported\
            \ values are linux and windows. Additional value may be defined in future\
            \ and can be one of: https://github.com/opencontainers/runtime-spec/blob/master/config.md#platform-specific-configuration\
            \ Clients should expect to handle additional values and treat unrecognized\
            \ values in this field as os: null"
      description: PodOS defines the OS parameters of a pod.
    io.k8s.api.core.v1.PodReadinessGate:
      required:
        - conditionType
      type: object
      properties:
        conditionType:
          type: string
          description:
            ConditionType refers to a condition in the pod's condition
            list with matching type.
      description: PodReadinessGate contains the reference to a pod condition
    io.k8s.api.core.v1.PodResourceClaim:
      required:
        - name
      type: object
      properties:
        name:
          type: string
          description:
            Name uniquely identifies this resource claim inside the pod.
            This must be a DNS_LABEL.
        source:
          $ref: "#/components/schemas/io.k8s.api.core.v1.ClaimSource"
      description:
        PodResourceClaim references exactly one ResourceClaim through a
        ClaimSource. It adds a name to it that uniquely identifies the ResourceClaim
        inside the Pod. Containers that need access to the ResourceClaim reference
        it with this name.
    io.k8s.api.core.v1.ClaimSource:
      type: object
      properties:
        resourceClaimName:
          type: string
          description:
            ResourceClaimName is the name of a ResourceClaim object in
            the same namespace as this pod.
        resourceClaimTemplateName:
          type: string
          description: |-
            ResourceClaimTemplateName is the name of a ResourceClaimTemplate object in the same namespace as this pod.

            The template will be used to create a new ResourceClaim, which will be bound to this pod. When this pod is deleted, the ResourceClaim will also be deleted. The pod name and resource name, along with a generated component, will be used to form a unique name for the ResourceClaim, which will be recorded in pod.status.resourceClaimStatuses.

            This field is immutable and no changes will be made to the corresponding ResourceClaim by the control plane after creating the ResourceClaim.
      description: |-
        ClaimSource describes a reference to a ResourceClaim.

        Exactly one of these fields should be set.  Consumers of this type must treat an empty object as if it has an unknown value.
    io.k8s.api.core.v1.PodSchedulingGate:
      required:
        - name
      type: object
      properties:
        name:
          type: string
          description:
            Name of the scheduling gate. Each scheduling gate must have
            a unique name field.
      description: PodSchedulingGate is associated to a Pod to guard its scheduling.
    io.k8s.api.core.v1.PodSecurityContext:
      type: object
      properties:
        fsGroup:
          type: integer
          description: |-
            A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:

            1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----

            If unset, the Kubelet will not modify the ownership and permissions of any volume. Note that this field cannot be set when spec.os.name is windows.
          format: int64
        fsGroupChangePolicy:
          type: string
          description: |-
            fsGroupChangePolicy defines behavior of changing ownership and permission of the volume before being exposed inside Pod. This field will only apply to volume types which support fsGroup based ownership(and permissions). It will have no effect on ephemeral volume types such as: secret, configmaps and emptydir. Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used. Note that this field cannot be set when spec.os.name is windows.

            Possible enum values:
             - `"Always"` indicates that volume's ownership and permissions should always be changed whenever volume is mounted inside a Pod. This the default behavior.
             - `"OnRootMismatch"` indicates that volume's ownership and permissions will be changed only when permission and ownership of root directory does not match with expected permissions on the volume. This can help shorten the time it takes to change ownership and permissions of a volume.
          enum:
            - Always
            - OnRootMismatch
        runAsGroup:
          type: integer
          description:
            "The GID to run the entrypoint of the container process. Uses\
            \ runtime default if unset. May also be set in SecurityContext.  If set\
            \ in both SecurityContext and PodSecurityContext, the value specified\
            \ in SecurityContext takes precedence for that container. Note that this\
            \ field cannot be set when spec.os.name is windows."
          format: int64
        runAsNonRoot:
          type: boolean
          description:
            "Indicates that the container must run as a non-root user.\
            \ If true, the Kubelet will validate the image at runtime to ensure that\
            \ it does not run as UID 0 (root) and fail to start the container if it\
            \ does. If unset or false, no such validation will be performed. May also\
            \ be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext,\
            \ the value specified in SecurityContext takes precedence."
        runAsUser:
          type: integer
          description:
            "The UID to run the entrypoint of the container process. Defaults\
            \ to user specified in image metadata if unspecified. May also be set\
            \ in SecurityContext.  If set in both SecurityContext and PodSecurityContext,\
            \ the value specified in SecurityContext takes precedence for that container.\
            \ Note that this field cannot be set when spec.os.name is windows."
          format: int64
        seLinuxOptions:
          $ref: "#/components/schemas/io.k8s.api.core.v1.SELinuxOptions"
        seccompProfile:
          $ref: "#/components/schemas/io.k8s.api.core.v1.SeccompProfile"
        supplementalGroups:
          type: array
          description:
            "A list of groups applied to the first process run in each\
            \ container, in addition to the container's primary GID, the fsGroup (if\
            \ specified), and group memberships defined in the container image for\
            \ the uid of the container process. If unspecified, no additional groups\
            \ are added to any container. Note that group memberships defined in the\
            \ container image for the uid of the container process are still effective,\
            \ even if they are not included in this list. Note that this field cannot\
            \ be set when spec.os.name is windows."
          items:
            type: integer
            format: int64
        sysctls:
          type: array
          description:
            Sysctls hold a list of namespaced sysctls used for the pod.
            Pods with unsupported sysctls (by the container runtime) might fail to
            launch. Note that this field cannot be set when spec.os.name is windows.
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.Sysctl"
        windowsOptions:
          $ref: "#/components/schemas/io.k8s.api.core.v1.WindowsSecurityContextOptions"
      description:
        PodSecurityContext holds pod-level security attributes and common
        container settings. Some fields are also present in container.securityContext.  Field
        values of container.securityContext take precedence over field values of PodSecurityContext.
    io.k8s.api.core.v1.Sysctl:
      required:
        - name
        - value
      type: object
      properties:
        name:
          type: string
          description: Name of a property to set
        value:
          type: string
          description: Value of a property to set
      description: Sysctl defines a kernel parameter to be set
    io.k8s.api.core.v1.Toleration:
      type: object
      properties:
        effect:
          type: string
          description: |-
            Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.

            Possible enum values:
             - `"NoExecute"` Evict any already-running pods that do not tolerate the taint. Currently enforced by NodeController.
             - `"NoSchedule"` Do not allow new pods to schedule onto the node unless they tolerate the taint, but allow all pods submitted to Kubelet without going through the scheduler to start, and allow all already-running pods to continue running. Enforced by the scheduler.
             - `"PreferNoSchedule"` Like TaintEffectNoSchedule, but the scheduler tries not to schedule new pods onto the node, rather than prohibiting new pods from scheduling onto the node entirely. Enforced by the scheduler.
          enum:
            - NoExecute
            - NoSchedule
            - PreferNoSchedule
        key:
          type: string
          description:
            "Key is the taint key that the toleration applies to. Empty\
            \ means match all taint keys. If the key is empty, operator must be Exists;\
            \ this combination means to match all values and all keys."
        operator:
          type: string
          description: |-
            Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.

            Possible enum values:
             - `"Equal"`
             - `"Exists"`
          enum:
            - Equal
            - Exists
        tolerationSeconds:
          type: integer
          description:
            "TolerationSeconds represents the period of time the toleration\
            \ (which must be of effect NoExecute, otherwise this field is ignored)\
            \ tolerates the taint. By default, it is not set, which means tolerate\
            \ the taint forever (do not evict). Zero and negative values will be treated\
            \ as 0 (evict immediately) by the system."
          format: int64
        value:
          type: string
          description:
            "Value is the taint value the toleration matches to. If the\
            \ operator is Exists, the value should be empty, otherwise just a regular\
            \ string."
      description:
        "The pod this Toleration is attached to tolerates any taint that\
        \ matches the triple <key,value,effect> using the matching operator <operator>."
    io.k8s.api.core.v1.TopologySpreadConstraint:
      required:
        - maxSkew
        - topologyKey
        - whenUnsatisfiable
      type: object
      properties:
        labelSelector:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        matchLabelKeys:
          type: array
          description: |-
            MatchLabelKeys is a set of pod label keys to select the pods over which spreading will be calculated. The keys are used to lookup values from the incoming pod labels, those key-value labels are ANDed with labelSelector to select the group of existing pods over which spreading will be calculated for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector. MatchLabelKeys cannot be set when LabelSelector isn't set. Keys that don't exist in the incoming pod labels will be ignored. A null or empty list means only match against labelSelector.

            This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
          items:
            type: string
          x-kubernetes-list-type: atomic
        maxSkew:
          type: integer
          description:
            "MaxSkew describes the degree to which pods may be unevenly\
            \ distributed. When `whenUnsatisfiable=DoNotSchedule`, it is the maximum\
            \ permitted difference between the number of matching pods in the target\
            \ topology and the global minimum. The global minimum is the minimum number\
            \ of matching pods in an eligible domain or zero if the number of eligible\
            \ domains is less than MinDomains. For example, in a 3-zone cluster, MaxSkew\
            \ is set to 1, and pods with the same labelSelector spread as 2/2/1: In\
            \ this case, the global minimum is 1. | zone1 | zone2 | zone3 | |  P P\
            \  |  P P  |   P   | - if MaxSkew is 1, incoming pod can only be scheduled\
            \ to zone3 to become 2/2/2; scheduling it onto zone1(zone2) would make\
            \ the ActualSkew(3-1) on zone1(zone2) violate MaxSkew(1). - if MaxSkew\
            \ is 2, incoming pod can be scheduled onto any zone. When `whenUnsatisfiable=ScheduleAnyway`,\
            \ it is used to give higher precedence to topologies that satisfy it.\
            \ It's a required field. Default value is 1 and 0 is not allowed."
          format: int32
        minDomains:
          type: integer
          description: |-
            MinDomains indicates a minimum number of eligible domains. When the number of eligible domains with matching topology keys is less than minDomains, Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed. And when the number of eligible domains with matching topology keys equals or greater than minDomains, this value has no effect on scheduling. As a result, when the number of eligible domains is less than minDomains, scheduler won't schedule more than maxSkew Pods to those domains. If value is nil, the constraint behaves as if MinDomains is equal to 1. Valid values are integers greater than 0. When value is not nil, WhenUnsatisfiable must be DoNotSchedule.

            For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same labelSelector spread as 2/2/2: | zone1 | zone2 | zone3 | |  P P  |  P P  |  P P  | The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0. In this situation, new pod with the same labelSelector cannot be scheduled, because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones, it will violate MaxSkew.

            This is a beta field and requires the MinDomainsInPodTopologySpread feature gate to be enabled (enabled by default).
          format: int32
        nodeAffinityPolicy:
          type: string
          description: |-
            NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector when calculating pod topology spread skew. Options are: - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations. - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.

            If this value is nil, the behavior is equivalent to the Honor policy. This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.

            Possible enum values:
             - `"Honor"` means use this scheduling directive when calculating pod topology spread skew.
             - `"Ignore"` means ignore this scheduling directive when calculating pod topology spread skew.
          enum:
            - Honor
            - Ignore
        nodeTaintsPolicy:
          type: string
          description: |-
            NodeTaintsPolicy indicates how we will treat node taints when calculating pod topology spread skew. Options are: - Honor: nodes without taints, along with tainted nodes for which the incoming pod has a toleration, are included. - Ignore: node taints are ignored. All nodes are included.

            If this value is nil, the behavior is equivalent to the Ignore policy. This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.

            Possible enum values:
             - `"Honor"` means use this scheduling directive when calculating pod topology spread skew.
             - `"Ignore"` means ignore this scheduling directive when calculating pod topology spread skew.
          enum:
            - Honor
            - Ignore
        topologyKey:
          type: string
          description:
            "TopologyKey is the key of node labels. Nodes that have a label\
            \ with this key and identical values are considered to be in the same\
            \ topology. We consider each <key, value> as a \"bucket\", and try to\
            \ put balanced number of pods into each bucket. We define a domain as\
            \ a particular instance of a topology. Also, we define an eligible domain\
            \ as a domain whose nodes meet the requirements of nodeAffinityPolicy\
            \ and nodeTaintsPolicy. e.g. If TopologyKey is \"kubernetes.io/hostname\"\
            , each Node is a domain of that topology. And, if TopologyKey is \"topology.kubernetes.io/zone\"\
            , each zone is a domain of that topology. It's a required field."
        whenUnsatisfiable:
          type: string
          description: |-
            WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy the spread constraint. - DoNotSchedule (default) tells the scheduler not to schedule it. - ScheduleAnyway tells the scheduler to schedule the pod in any location,
              but giving higher precedence to topologies that would help reduce the
              skew.
            A constraint is considered "Unsatisfiable" for an incoming pod if and only if every possible node assignment for that pod would violate "MaxSkew" on some topology. For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same labelSelector spread as 3/1/1: | zone1 | zone2 | zone3 | | P P P |   P   |   P   | If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler won't make it *more* imbalanced. It's a required field.

            Possible enum values:
             - `"DoNotSchedule"` instructs the scheduler not to schedule the pod when constraints are not satisfied.
             - `"ScheduleAnyway"` instructs the scheduler to schedule the pod even if constraints are not satisfied.
          enum:
            - DoNotSchedule
            - ScheduleAnyway
      description:
        TopologySpreadConstraint specifies how to spread matching pods
        among the given topology.
    io.k8s.api.core.v1.Volume:
      required:
        - name
      type: object
      properties:
        awsElasticBlockStore:
          $ref: "#/components/schemas/io.k8s.api.core.v1.AWSElasticBlockStoreVolumeSource"
        azureDisk:
          $ref: "#/components/schemas/io.k8s.api.core.v1.AzureDiskVolumeSource"
        azureFile:
          $ref: "#/components/schemas/io.k8s.api.core.v1.AzureFileVolumeSource"
        cephfs:
          $ref: "#/components/schemas/io.k8s.api.core.v1.CephFSVolumeSource"
        cinder:
          $ref: "#/components/schemas/io.k8s.api.core.v1.CinderVolumeSource"
        configMap:
          $ref: "#/components/schemas/io.k8s.api.core.v1.ConfigMapVolumeSource"
        csi:
          $ref: "#/components/schemas/io.k8s.api.core.v1.CSIVolumeSource"
        downwardAPI:
          $ref: "#/components/schemas/io.k8s.api.core.v1.DownwardAPIVolumeSource"
        emptyDir:
          $ref: "#/components/schemas/io.k8s.api.core.v1.EmptyDirVolumeSource"
        ephemeral:
          $ref: "#/components/schemas/io.k8s.api.core.v1.EphemeralVolumeSource"
        fc:
          $ref: "#/components/schemas/io.k8s.api.core.v1.FCVolumeSource"
        flexVolume:
          $ref: "#/components/schemas/io.k8s.api.core.v1.FlexVolumeSource"
        flocker:
          $ref: "#/components/schemas/io.k8s.api.core.v1.FlockerVolumeSource"
        gcePersistentDisk:
          $ref: "#/components/schemas/io.k8s.api.core.v1.GCEPersistentDiskVolumeSource"
        gitRepo:
          $ref: "#/components/schemas/io.k8s.api.core.v1.GitRepoVolumeSource"
        glusterfs:
          $ref: "#/components/schemas/io.k8s.api.core.v1.GlusterfsVolumeSource"
        hostPath:
          $ref: "#/components/schemas/io.k8s.api.core.v1.HostPathVolumeSource"
        iscsi:
          $ref: "#/components/schemas/io.k8s.api.core.v1.ISCSIVolumeSource"
        name:
          type: string
          description:
            "name of the volume. Must be a DNS_LABEL and unique within\
            \ the pod. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"
        nfs:
          $ref: "#/components/schemas/io.k8s.api.core.v1.NFSVolumeSource"
        persistentVolumeClaim:
          $ref: "#/components/schemas/io.k8s.api.core.v1.PersistentVolumeClaimVolumeSource"
        photonPersistentDisk:
          $ref: "#/components/schemas/io.k8s.api.core.v1.PhotonPersistentDiskVolumeSource"
        portworxVolume:
          $ref: "#/components/schemas/io.k8s.api.core.v1.PortworxVolumeSource"
        projected:
          $ref: "#/components/schemas/io.k8s.api.core.v1.ProjectedVolumeSource"
        quobyte:
          $ref: "#/components/schemas/io.k8s.api.core.v1.QuobyteVolumeSource"
        rbd:
          $ref: "#/components/schemas/io.k8s.api.core.v1.RBDVolumeSource"
        scaleIO:
          $ref: "#/components/schemas/io.k8s.api.core.v1.ScaleIOVolumeSource"
        secret:
          $ref: "#/components/schemas/io.k8s.api.core.v1.SecretVolumeSource"
        storageos:
          $ref: "#/components/schemas/io.k8s.api.core.v1.StorageOSVolumeSource"
        vsphereVolume:
          $ref: "#/components/schemas/io.k8s.api.core.v1.VsphereVirtualDiskVolumeSource"
      description:
        Volume represents a named volume in a pod that may be accessed
        by any container in the pod.
    io.k8s.api.core.v1.AWSElasticBlockStoreVolumeSource:
      required:
        - volumeID
      type: object
      properties:
        fsType:
          type: string
          description:
            "fsType is the filesystem type of the volume that you want\
            \ to mount. Tip: Ensure that the filesystem type is supported by the host\
            \ operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly\
            \ inferred to be \"ext4\" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore"
        partition:
          type: integer
          description:
            "partition is the partition in the volume that you want to\
            \ mount. If omitted, the default is to mount by volume name. Examples:\
            \ For volume /dev/sda1, you specify the partition as \"1\". Similarly,\
            \ the volume partition for /dev/sda is \"0\" (or you can leave the property\
            \ empty)."
          format: int32
        readOnly:
          type: boolean
          description:
            "readOnly value true will force the readOnly setting in VolumeMounts.\
            \ More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore"
        volumeID:
          type: string
          description:
            "volumeID is unique ID of the persistent disk resource in AWS\
            \ (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore"
      description: |-
        Represents a Persistent Disk resource in AWS.

        An AWS EBS disk must exist before mounting to a container. The disk must also be in the same AWS zone as the kubelet. An AWS EBS disk can only be mounted as read/write once. AWS EBS volumes support ownership management and SELinux relabeling.
    io.k8s.api.core.v1.AzureDiskVolumeSource:
      required:
        - diskName
        - diskURI
      type: object
      properties:
        cachingMode:
          type: string
          description: |-
            cachingMode is the Host Caching mode: None, Read Only, Read Write.

            Possible enum values:
             - `"None"`
             - `"ReadOnly"`
             - `"ReadWrite"`
          enum:
            - None
            - ReadOnly
            - ReadWrite
        diskName:
          type: string
          description: diskName is the Name of the data disk in the blob storage
        diskURI:
          type: string
          description: diskURI is the URI of data disk in the blob storage
        fsType:
          type: string
          description:
            "fsType is Filesystem type to mount. Must be a filesystem type\
            \ supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\"\
            . Implicitly inferred to be \"ext4\" if unspecified."
        kind:
          type: string
          description: |-
            kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared

            Possible enum values:
             - `"Dedicated"`
             - `"Managed"`
             - `"Shared"`
          enum:
            - Dedicated
            - Managed
            - Shared
        readOnly:
          type: boolean
          description:
            readOnly Defaults to false (read/write). ReadOnly here will
            force the ReadOnly setting in VolumeMounts.
      description:
        AzureDisk represents an Azure Data Disk mount on the host and bind
        mount to the pod.
    io.k8s.api.core.v1.AzureFileVolumeSource:
      required:
        - secretName
        - shareName
      type: object
      properties:
        readOnly:
          type: boolean
          description:
            readOnly defaults to false (read/write). ReadOnly here will
            force the ReadOnly setting in VolumeMounts.
        secretName:
          type: string
          description:
            secretName is the  name of secret that contains Azure Storage
            Account Name and Key
        shareName:
          type: string
          description: shareName is the azure share Name
      description:
        AzureFile represents an Azure File Service mount on the host and
        bind mount to the pod.
    io.k8s.api.core.v1.CephFSVolumeSource:
      required:
        - monitors
      type: object
      properties:
        monitors:
          type: array
          description:
            "monitors is Required: Monitors is a collection of Ceph monitors\
            \ More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it"
          items:
            type: string
        path:
          type: string
          description:
            "path is Optional: Used as the mounted root, rather than the\
            \ full Ceph tree, default is /"
        readOnly:
          type: boolean
          description:
            "readOnly is Optional: Defaults to false (read/write). ReadOnly\
            \ here will force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it"
        secretFile:
          type: string
          description:
            "secretFile is Optional: SecretFile is the path to key ring\
            \ for User, default is /etc/ceph/user.secret More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it"
        secretRef:
          $ref: "#/components/schemas/io.k8s.api.core.v1.LocalObjectReference"
        user:
          type: string
          description:
            "user is optional: User is the rados user name, default is\
            \ admin More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it"
      description:
        Represents a Ceph Filesystem mount that lasts the lifetime of a
        pod Cephfs volumes do not support ownership management or SELinux relabeling.
    io.k8s.api.core.v1.CinderVolumeSource:
      required:
        - volumeID
      type: object
      properties:
        fsType:
          type: string
          description:
            "fsType is the filesystem type to mount. Must be a filesystem\
            \ type supported by the host operating system. Examples: \"ext4\", \"\
            xfs\", \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified. More\
            \ info: https://examples.k8s.io/mysql-cinder-pd/README.md"
        readOnly:
          type: boolean
          description:
            "readOnly defaults to false (read/write). ReadOnly here will\
            \ force the ReadOnly setting in VolumeMounts. More info: https://examples.k8s.io/mysql-cinder-pd/README.md"
        secretRef:
          $ref: "#/components/schemas/io.k8s.api.core.v1.LocalObjectReference"
        volumeID:
          type: string
          description:
            "volumeID used to identify the volume in cinder. More info:\
            \ https://examples.k8s.io/mysql-cinder-pd/README.md"
      description:
        Represents a cinder volume resource in Openstack. A Cinder volume
        must exist before mounting to a container. The volume must also be in the
        same region as the kubelet. Cinder volumes support ownership management and
        SELinux relabeling.
    io.k8s.api.core.v1.ConfigMapVolumeSource:
      type: object
      properties:
        defaultMode:
          type: integer
          description:
            "defaultMode is optional: mode bits used to set permissions\
            \ on created files by default. Must be an octal value between 0000 and\
            \ 0777 or a decimal value between 0 and 511. YAML accepts both octal and\
            \ decimal values, JSON requires decimal values for mode bits. Defaults\
            \ to 0644. Directories within the path are not affected by this setting.\
            \ This might be in conflict with other options that affect the file mode,\
            \ like fsGroup, and the result can be other mode bits set."
          format: int32
        items:
          type: array
          description:
            "items if unspecified, each key-value pair in the Data field\
            \ of the referenced ConfigMap will be projected into the volume as a file\
            \ whose name is the key and content is the value. If specified, the listed\
            \ keys will be projected into the specified paths, and unlisted keys will\
            \ not be present. If a key is specified which is not present in the ConfigMap,\
            \ the volume setup will error unless it is marked optional. Paths must\
            \ be relative and may not contain the '..' path or start with '..'."
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.KeyToPath"
        name:
          type: string
          description: "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"
        optional:
          type: boolean
          description:
            optional specify whether the ConfigMap or its keys must be
            defined
      description: |-
        Adapts a ConfigMap into a volume.

        The contents of the target ConfigMap's Data field will be presented in a volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. ConfigMap volumes support ownership management and SELinux relabeling.
    io.k8s.api.core.v1.KeyToPath:
      required:
        - key
        - path
      type: object
      properties:
        key:
          type: string
          description: key is the key to project.
        mode:
          type: integer
          description:
            "mode is Optional: mode bits used to set permissions on this\
            \ file. Must be an octal value between 0000 and 0777 or a decimal value\
            \ between 0 and 511. YAML accepts both octal and decimal values, JSON\
            \ requires decimal values for mode bits. If not specified, the volume\
            \ defaultMode will be used. This might be in conflict with other options\
            \ that affect the file mode, like fsGroup, and the result can be other\
            \ mode bits set."
          format: int32
        path:
          type: string
          description:
            path is the relative path of the file to map the key to. May
            not be an absolute path. May not contain the path element '..'. May not
            start with the string '..'.
      description: Maps a string key to a path within a volume.
    io.k8s.api.core.v1.CSIVolumeSource:
      required:
        - driver
      type: object
      properties:
        driver:
          type: string
          description:
            driver is the name of the CSI driver that handles this volume.
            Consult with your admin for the correct name as registered in the cluster.
        fsType:
          type: string
          description:
            "fsType to mount. Ex. \"ext4\", \"xfs\", \"ntfs\". If not provided,\
            \ the empty value is passed to the associated CSI driver which will determine\
            \ the default filesystem to apply."
        nodePublishSecretRef:
          $ref: "#/components/schemas/io.k8s.api.core.v1.LocalObjectReference"
        readOnly:
          type: boolean
          description:
            readOnly specifies a read-only configuration for the volume.
            Defaults to false (read/write).
        volumeAttributes:
          type: object
          additionalProperties:
            type: string
          description:
            volumeAttributes stores driver-specific properties that are
            passed to the CSI driver. Consult your driver's documentation for supported
            values.
      description:
        "Represents a source location of a volume to mount, managed by\
        \ an external CSI driver"
    io.k8s.api.core.v1.DownwardAPIVolumeSource:
      type: object
      properties:
        defaultMode:
          type: integer
          description:
            "Optional: mode bits to use on created files by default. Must\
            \ be a Optional: mode bits used to set permissions on created files by\
            \ default. Must be an octal value between 0000 and 0777 or a decimal value\
            \ between 0 and 511. YAML accepts both octal and decimal values, JSON\
            \ requires decimal values for mode bits. Defaults to 0644. Directories\
            \ within the path are not affected by this setting. This might be in conflict\
            \ with other options that affect the file mode, like fsGroup, and the\
            \ result can be other mode bits set."
          format: int32
        items:
          type: array
          description: Items is a list of downward API volume file
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.DownwardAPIVolumeFile"
      description:
        DownwardAPIVolumeSource represents a volume containing downward
        API info. Downward API volumes support ownership management and SELinux relabeling.
    io.k8s.api.core.v1.DownwardAPIVolumeFile:
      required:
        - path
      type: object
      properties:
        fieldRef:
          $ref: "#/components/schemas/io.k8s.api.core.v1.ObjectFieldSelector"
        mode:
          type: integer
          description:
            "Optional: mode bits used to set permissions on this file,\
            \ must be an octal value between 0000 and 0777 or a decimal value between\
            \ 0 and 511. YAML accepts both octal and decimal values, JSON requires\
            \ decimal values for mode bits. If not specified, the volume defaultMode\
            \ will be used. This might be in conflict with other options that affect\
            \ the file mode, like fsGroup, and the result can be other mode bits set."
          format: int32
        path:
          type: string
          description:
            "Required: Path is  the relative path name of the file to be\
            \ created. Must not be absolute or contain the '..' path. Must be utf-8\
            \ encoded. The first item of the relative path must not start with '..'"
        resourceFieldRef:
          $ref: "#/components/schemas/io.k8s.api.core.v1.ResourceFieldSelector"
      description:
        DownwardAPIVolumeFile represents information to create the file
        containing the pod field
    io.k8s.api.core.v1.EmptyDirVolumeSource:
      type: object
      properties:
        medium:
          type: string
          description:
            "medium represents what type of storage medium should back\
            \ this directory. The default is \"\" which means to use the node's default\
            \ medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir"
        sizeLimit:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.api.resource.Quantity"
      description:
        Represents an empty directory for a pod. Empty directory volumes
        support ownership management and SELinux relabeling.
    io.k8s.api.core.v1.EphemeralVolumeSource:
      type: object
      properties:
        volumeClaimTemplate:
          $ref: "#/components/schemas/io.k8s.api.core.v1.PersistentVolumeClaimTemplate"
      description:
        Represents an ephemeral volume that is handled by a normal storage
        driver.
    io.k8s.api.core.v1.PersistentVolumeClaimTemplate:
      required:
        - spec
      type: object
      properties:
        metadata:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        spec:
          $ref: "#/components/schemas/io.k8s.api.core.v1.PersistentVolumeClaimSpec"
      description:
        PersistentVolumeClaimTemplate is used to produce PersistentVolumeClaim
        objects as part of an EphemeralVolumeSource.
    io.k8s.api.core.v1.PersistentVolumeClaimSpec:
      type: object
      properties:
        accessModes:
          type: array
          description:
            "accessModes contains the desired access modes the volume should\
            \ have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1"
          items:
            type: string
        dataSource:
          $ref: "#/components/schemas/io.k8s.api.core.v1.TypedLocalObjectReference"
        dataSourceRef:
          $ref: "#/components/schemas/io.k8s.api.core.v1.TypedObjectReference"
        resources:
          $ref: "#/components/schemas/io.k8s.api.core.v1.VolumeResourceRequirements"
        selector:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        storageClassName:
          type: string
          description:
            "storageClassName is the name of the StorageClass required\
            \ by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1"
        volumeAttributesClassName:
          type: string
          description:
            "volumeAttributesClassName may be used to set the VolumeAttributesClass\
            \ used by this claim. If specified, the CSI driver will create or update\
            \ the volume with the attributes defined in the corresponding VolumeAttributesClass.\
            \ This has a different purpose than storageClassName, it can be changed\
            \ after the claim is created. An empty string value means that no VolumeAttributesClass\
            \ will be applied to the claim but it's not allowed to reset this field\
            \ to empty string once it is set. If unspecified and the PersistentVolumeClaim\
            \ is unbound, the default VolumeAttributesClass will be set by the persistentvolume\
            \ controller if it exists. If the resource referred to by volumeAttributesClass\
            \ does not exist, this PersistentVolumeClaim will be set to a Pending\
            \ state, as reflected by the modifyVolumeStatus field, until such as a\
            \ resource exists. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#volumeattributesclass\
            \ (Alpha) Using this field requires the VolumeAttributesClass feature\
            \ gate to be enabled."
        volumeMode:
          type: string
          description: |-
            volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.

            Possible enum values:
             - `"Block"` means the volume will not be formatted with a filesystem and will remain a raw block device.
             - `"Filesystem"` means the volume will be or is formatted with a filesystem.
          enum:
            - Block
            - Filesystem
        volumeName:
          type: string
          description:
            volumeName is the binding reference to the PersistentVolume
            backing this claim.
      description:
        PersistentVolumeClaimSpec describes the common attributes of storage
        devices and allows a Source for provider-specific attributes
    io.k8s.api.core.v1.TypedLocalObjectReference:
      required:
        - kind
        - name
      type: object
      properties:
        apiGroup:
          type: string
          description:
            "APIGroup is the group for the resource being referenced. If\
            \ APIGroup is not specified, the specified Kind must be in the core API\
            \ group. For any other third-party types, APIGroup is required."
        kind:
          type: string
          description: Kind is the type of resource being referenced
        name:
          type: string
          description: Name is the name of resource being referenced
      description:
        TypedLocalObjectReference contains enough information to let you
        locate the typed referenced object inside the same namespace.
      x-kubernetes-map-type: atomic
    io.k8s.api.core.v1.TypedObjectReference:
      required:
        - kind
        - name
      type: object
      properties:
        apiGroup:
          type: string
          description:
            "APIGroup is the group for the resource being referenced. If\
            \ APIGroup is not specified, the specified Kind must be in the core API\
            \ group. For any other third-party types, APIGroup is required."
        kind:
          type: string
          description: Kind is the type of resource being referenced
        name:
          type: string
          description: Name is the name of resource being referenced
        namespace:
          type: string
          description:
            "Namespace is the namespace of resource being referenced Note\
            \ that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant\
            \ object is required in the referent namespace to allow that namespace's\
            \ owner to accept the reference. See the ReferenceGrant documentation\
            \ for details. (Alpha) This field requires the CrossNamespaceVolumeDataSource\
            \ feature gate to be enabled."
    io.k8s.api.core.v1.VolumeResourceRequirements:
      type: object
      properties:
        limits:
          type: object
          additionalProperties:
            $ref: "#/components/schemas/io.k8s.apimachinery.pkg.api.resource.Quantity"
          description:
            "Limits describes the maximum amount of compute resources allowed.\
            \ More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/"
        requests:
          type: object
          additionalProperties:
            $ref: "#/components/schemas/io.k8s.apimachinery.pkg.api.resource.Quantity"
          description:
            "Requests describes the minimum amount of compute resources\
            \ required. If Requests is omitted for a container, it defaults to Limits\
            \ if that is explicitly specified, otherwise to an implementation-defined\
            \ value. Requests cannot exceed Limits. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/"
      description:
        VolumeResourceRequirements describes the storage resource requirements
        for a volume.
    io.k8s.api.core.v1.FCVolumeSource:
      type: object
      properties:
        fsType:
          type: string
          description:
            "fsType is the filesystem type to mount. Must be a filesystem\
            \ type supported by the host operating system. Ex. \"ext4\", \"xfs\",\
            \ \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified."
        lun:
          type: integer
          description: "lun is Optional: FC target lun number"
          format: int32
        readOnly:
          type: boolean
          description:
            "readOnly is Optional: Defaults to false (read/write). ReadOnly\
            \ here will force the ReadOnly setting in VolumeMounts."
        targetWWNs:
          type: array
          description: "targetWWNs is Optional: FC target worldwide names (WWNs)"
          items:
            type: string
        wwids:
          type: array
          description:
            "wwids Optional: FC volume world wide identifiers (wwids) Either\
            \ wwids or combination of targetWWNs and lun must be set, but not both\
            \ simultaneously."
          items:
            type: string
      description:
        Represents a Fibre Channel volume. Fibre Channel volumes can only
        be mounted as read/write once. Fibre Channel volumes support ownership management
        and SELinux relabeling.
    io.k8s.api.core.v1.FlexVolumeSource:
      required:
        - driver
      type: object
      properties:
        driver:
          type: string
          description: driver is the name of the driver to use for this volume.
        fsType:
          type: string
          description:
            "fsType is the filesystem type to mount. Must be a filesystem\
            \ type supported by the host operating system. Ex. \"ext4\", \"xfs\",\
            \ \"ntfs\". The default filesystem depends on FlexVolume script."
        options:
          type: object
          additionalProperties:
            type: string
          description:
            "options is Optional: this field holds extra command options\
            \ if any."
        readOnly:
          type: boolean
          description:
            "readOnly is Optional: defaults to false (read/write). ReadOnly\
            \ here will force the ReadOnly setting in VolumeMounts."
        secretRef:
          $ref: "#/components/schemas/io.k8s.api.core.v1.LocalObjectReference"
      description:
        FlexVolume represents a generic volume resource that is provisioned/attached
        using an exec based plugin.
    io.k8s.api.core.v1.FlockerVolumeSource:
      type: object
      properties:
        datasetName:
          type: string
          description:
            datasetName is Name of the dataset stored as metadata -> name
            on the dataset for Flocker should be considered as deprecated
        datasetUUID:
          type: string
          description:
            datasetUUID is the UUID of the dataset. This is unique identifier
            of a Flocker dataset
      description:
        Represents a Flocker volume mounted by the Flocker agent. One and
        only one of datasetName and datasetUUID should be set. Flocker volumes do
        not support ownership management or SELinux relabeling.
    io.k8s.api.core.v1.GCEPersistentDiskVolumeSource:
      required:
        - pdName
      type: object
      properties:
        fsType:
          type: string
          description:
            "fsType is filesystem type of the volume that you want to mount.\
            \ Tip: Ensure that the filesystem type is supported by the host operating\
            \ system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly inferred to\
            \ be \"ext4\" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk"
        partition:
          type: integer
          description:
            "partition is the partition in the volume that you want to\
            \ mount. If omitted, the default is to mount by volume name. Examples:\
            \ For volume /dev/sda1, you specify the partition as \"1\". Similarly,\
            \ the volume partition for /dev/sda is \"0\" (or you can leave the property\
            \ empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk"
          format: int32
        pdName:
          type: string
          description:
            "pdName is unique name of the PD resource in GCE. Used to identify\
            \ the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk"
        readOnly:
          type: boolean
          description:
            "readOnly here will force the ReadOnly setting in VolumeMounts.\
            \ Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk"
      description: |-
        Represents a Persistent Disk resource in Google Compute Engine.

        A GCE PD must exist before mounting to a container. The disk must also be in the same GCE project and zone as the kubelet. A GCE PD can only be mounted as read/write once or read-only many times. GCE PDs support ownership management and SELinux relabeling.
    io.k8s.api.core.v1.GitRepoVolumeSource:
      required:
        - repository
      type: object
      properties:
        directory:
          type: string
          description:
            "directory is the target directory name. Must not contain or\
            \ start with '..'.  If '.' is supplied, the volume directory will be the\
            \ git repository.  Otherwise, if specified, the volume will contain the\
            \ git repository in the subdirectory with the given name."
        repository:
          type: string
          description: repository is the URL
        revision:
          type: string
          description: revision is the commit hash for the specified revision.
      description: |-
        Represents a volume that is populated with the contents of a git repository. Git repo volumes do not support ownership management. Git repo volumes support SELinux relabeling.

        DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
    io.k8s.api.core.v1.GlusterfsVolumeSource:
      required:
        - endpoints
        - path
      type: object
      properties:
        endpoints:
          type: string
          description:
            "endpoints is the endpoint name that details Glusterfs topology.\
            \ More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod"
        path:
          type: string
          description: "path is the Glusterfs volume path. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod"
        readOnly:
          type: boolean
          description:
            "readOnly here will force the Glusterfs volume to be mounted\
            \ with read-only permissions. Defaults to false. More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod"
      description:
        Represents a Glusterfs mount that lasts the lifetime of a pod.
        Glusterfs volumes do not support ownership management or SELinux relabeling.
    io.k8s.api.core.v1.HostPathVolumeSource:
      required:
        - path
      type: object
      properties:
        path:
          type: string
          description:
            "path of the directory on the host. If the path is a symlink,\
            \ it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath"
        type:
          type: string
          description: |-
            type for HostPath Volume Defaults to "" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath

            Possible enum values:
             - `""` For backwards compatible, leave it empty if unset
             - `"BlockDevice"` A block device must exist at the given path
             - `"CharDevice"` A character device must exist at the given path
             - `"Directory"` A directory must exist at the given path
             - `"DirectoryOrCreate"` If nothing exists at the given path, an empty directory will be created there as needed with file mode 0755, having the same group and ownership with Kubelet.
             - `"File"` A file must exist at the given path
             - `"FileOrCreate"` If nothing exists at the given path, an empty file will be created there as needed with file mode 0644, having the same group and ownership with Kubelet.
             - `"Socket"` A UNIX socket must exist at the given path
          enum:
            - ""
            - BlockDevice
            - CharDevice
            - Directory
            - DirectoryOrCreate
            - File
            - FileOrCreate
            - Socket
      description:
        Represents a host path mapped into a pod. Host path volumes do
        not support ownership management or SELinux relabeling.
    io.k8s.api.core.v1.ISCSIVolumeSource:
      required:
        - iqn
        - lun
        - targetPortal
      type: object
      properties:
        chapAuthDiscovery:
          type: boolean
          description:
            chapAuthDiscovery defines whether support iSCSI Discovery CHAP
            authentication
        chapAuthSession:
          type: boolean
          description:
            chapAuthSession defines whether support iSCSI Session CHAP
            authentication
        fsType:
          type: string
          description:
            "fsType is the filesystem type of the volume that you want\
            \ to mount. Tip: Ensure that the filesystem type is supported by the host\
            \ operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly\
            \ inferred to be \"ext4\" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi"
        initiatorName:
          type: string
          description:
            "initiatorName is the custom iSCSI Initiator Name. If initiatorName\
            \ is specified with iscsiInterface simultaneously, new iSCSI interface\
            \ <target portal>:<volume name> will be created for the connection."
        iqn:
          type: string
          description: iqn is the target iSCSI Qualified Name.
        iscsiInterface:
          type: string
          description:
            iscsiInterface is the interface Name that uses an iSCSI transport.
            Defaults to 'default' (tcp).
        lun:
          type: integer
          description: lun represents iSCSI Target Lun number.
          format: int32
        portals:
          type: array
          description:
            portals is the iSCSI Target Portal List. The portal is either
            an IP or ip_addr:port if the port is other than default (typically TCP
            ports 860 and 3260).
          items:
            type: string
        readOnly:
          type: boolean
          description:
            readOnly here will force the ReadOnly setting in VolumeMounts.
            Defaults to false.
        secretRef:
          $ref: "#/components/schemas/io.k8s.api.core.v1.LocalObjectReference"
        targetPortal:
          type: string
          description:
            targetPortal is iSCSI Target Portal. The Portal is either an
            IP or ip_addr:port if the port is other than default (typically TCP ports
            860 and 3260).
      description:
        Represents an ISCSI disk. ISCSI volumes can only be mounted as
        read/write once. ISCSI volumes support ownership management and SELinux relabeling.
    io.k8s.api.core.v1.NFSVolumeSource:
      required:
        - path
        - server
      type: object
      properties:
        path:
          type: string
          description: "path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs"
        readOnly:
          type: boolean
          description:
            "readOnly here will force the NFS export to be mounted with\
            \ read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs"
        server:
          type: string
          description:
            "server is the hostname or IP address of the NFS server. More\
            \ info: https://kubernetes.io/docs/concepts/storage/volumes#nfs"
      description:
        Represents an NFS mount that lasts the lifetime of a pod. NFS volumes
        do not support ownership management or SELinux relabeling.
    io.k8s.api.core.v1.PersistentVolumeClaimVolumeSource:
      required:
        - claimName
      type: object
      properties:
        claimName:
          type: string
          description:
            "claimName is the name of a PersistentVolumeClaim in the same\
            \ namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims"
        readOnly:
          type: boolean
          description:
            readOnly Will force the ReadOnly setting in VolumeMounts. Default
            false.
      description:
        "PersistentVolumeClaimVolumeSource references the user's PVC in\
        \ the same namespace. This volume finds the bound PV and mounts that volume\
        \ for the pod. A PersistentVolumeClaimVolumeSource is, essentially, a wrapper\
        \ around another type of volume that is owned by someone else (the system)."
    io.k8s.api.core.v1.PhotonPersistentDiskVolumeSource:
      required:
        - pdID
      type: object
      properties:
        fsType:
          type: string
          description:
            "fsType is the filesystem type to mount. Must be a filesystem\
            \ type supported by the host operating system. Ex. \"ext4\", \"xfs\",\
            \ \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified."
        pdID:
          type: string
          description:
            pdID is the ID that identifies Photon Controller persistent
            disk
      description: Represents a Photon Controller persistent disk resource.
    io.k8s.api.core.v1.PortworxVolumeSource:
      required:
        - volumeID
      type: object
      properties:
        fsType:
          type: string
          description:
            "fSType represents the filesystem type to mount Must be a filesystem\
            \ type supported by the host operating system. Ex. \"ext4\", \"xfs\".\
            \ Implicitly inferred to be \"ext4\" if unspecified."
        readOnly:
          type: boolean
          description:
            readOnly defaults to false (read/write). ReadOnly here will
            force the ReadOnly setting in VolumeMounts.
        volumeID:
          type: string
          description: volumeID uniquely identifies a Portworx volume
      description: PortworxVolumeSource represents a Portworx volume resource.
    io.k8s.api.core.v1.ProjectedVolumeSource:
      type: object
      properties:
        defaultMode:
          type: integer
          description:
            "defaultMode are the mode bits used to set permissions on created\
            \ files by default. Must be an octal value between 0000 and 0777 or a\
            \ decimal value between 0 and 511. YAML accepts both octal and decimal\
            \ values, JSON requires decimal values for mode bits. Directories within\
            \ the path are not affected by this setting. This might be in conflict\
            \ with other options that affect the file mode, like fsGroup, and the\
            \ result can be other mode bits set."
          format: int32
        sources:
          type: array
          description: sources is the list of volume projections
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.VolumeProjection"
      description: Represents a projected volume source
    io.k8s.api.core.v1.VolumeProjection:
      type: object
      properties:
        clusterTrustBundle:
          $ref: "#/components/schemas/io.k8s.api.core.v1.ClusterTrustBundleProjection"
        configMap:
          $ref: "#/components/schemas/io.k8s.api.core.v1.ConfigMapProjection"
        downwardAPI:
          $ref: "#/components/schemas/io.k8s.api.core.v1.DownwardAPIProjection"
        secret:
          $ref: "#/components/schemas/io.k8s.api.core.v1.SecretProjection"
        serviceAccountToken:
          $ref: "#/components/schemas/io.k8s.api.core.v1.ServiceAccountTokenProjection"
      description:
        Projection that may be projected along with other supported volume
        types
    io.k8s.api.core.v1.ClusterTrustBundleProjection:
      required:
        - path
      type: object
      properties:
        labelSelector:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector"
        name:
          type: string
          description:
            Select a single ClusterTrustBundle by object name.  Mutually-exclusive
            with signerName and labelSelector.
        optional:
          type: boolean
          description:
            "If true, don't block pod startup if the referenced ClusterTrustBundle(s)\
            \ aren't available.  If using name, then the named ClusterTrustBundle\
            \ is allowed not to exist.  If using signerName, then the combination\
            \ of signerName and labelSelector is allowed to match zero ClusterTrustBundles."
        path:
          type: string
          description: Relative path from the volume root to write the bundle.
        signerName:
          type: string
          description:
            Select all ClusterTrustBundles that match this signer name.
            Mutually-exclusive with name.  The contents of all selected ClusterTrustBundles
            will be unified and deduplicated.
      description:
        ClusterTrustBundleProjection describes how to select a set of ClusterTrustBundle
        objects and project their contents into the pod filesystem.
    io.k8s.api.core.v1.ConfigMapProjection:
      type: object
      properties:
        items:
          type: array
          description:
            "items if unspecified, each key-value pair in the Data field\
            \ of the referenced ConfigMap will be projected into the volume as a file\
            \ whose name is the key and content is the value. If specified, the listed\
            \ keys will be projected into the specified paths, and unlisted keys will\
            \ not be present. If a key is specified which is not present in the ConfigMap,\
            \ the volume setup will error unless it is marked optional. Paths must\
            \ be relative and may not contain the '..' path or start with '..'."
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.KeyToPath"
        name:
          type: string
          description: "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"
        optional:
          type: boolean
          description:
            optional specify whether the ConfigMap or its keys must be
            defined
      description: |-
        Adapts a ConfigMap into a projected volume.

        The contents of the target ConfigMap's Data field will be presented in a projected volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. Note that this is identical to a configmap volume source without the default mode.
    io.k8s.api.core.v1.DownwardAPIProjection:
      type: object
      properties:
        items:
          type: array
          description: Items is a list of DownwardAPIVolume file
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.DownwardAPIVolumeFile"
      description:
        Represents downward API info for projecting into a projected volume.
        Note that this is identical to a downwardAPI volume source without the default
        mode.
    io.k8s.api.core.v1.SecretProjection:
      type: object
      properties:
        items:
          type: array
          description:
            "items if unspecified, each key-value pair in the Data field\
            \ of the referenced Secret will be projected into the volume as a file\
            \ whose name is the key and content is the value. If specified, the listed\
            \ keys will be projected into the specified paths, and unlisted keys will\
            \ not be present. If a key is specified which is not present in the Secret,\
            \ the volume setup will error unless it is marked optional. Paths must\
            \ be relative and may not contain the '..' path or start with '..'."
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.KeyToPath"
        name:
          type: string
          description: "Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"
        optional:
          type: boolean
          description:
            optional field specify whether the Secret or its key must be
            defined
      description: |-
        Adapts a secret into a projected volume.

        The contents of the target Secret's Data field will be presented in a projected volume as files using the keys in the Data field as the file names. Note that this is identical to a secret volume source without the default mode.
    io.k8s.api.core.v1.ServiceAccountTokenProjection:
      required:
        - path
      type: object
      properties:
        audience:
          type: string
          description:
            "audience is the intended audience of the token. A recipient\
            \ of a token must identify itself with an identifier specified in the\
            \ audience of the token, and otherwise should reject the token. The audience\
            \ defaults to the identifier of the apiserver."
        expirationSeconds:
          type: integer
          description:
            "expirationSeconds is the requested duration of validity of\
            \ the service account token. As the token approaches expiration, the kubelet\
            \ volume plugin will proactively rotate the service account token. The\
            \ kubelet will start trying to rotate the token if the token is older\
            \ than 80 percent of its time to live or if the token is older than 24\
            \ hours.Defaults to 1 hour and must be at least 10 minutes."
          format: int64
        path:
          type: string
          description:
            path is the path relative to the mount point of the file to
            project the token into.
      description:
        ServiceAccountTokenProjection represents a projected service account
        token volume. This projection can be used to insert a service account token
        into the pods runtime filesystem for use against APIs (Kubernetes API Server
        or otherwise).
    io.k8s.api.core.v1.QuobyteVolumeSource:
      required:
        - registry
        - volume
      type: object
      properties:
        group:
          type: string
          description: group to map volume access to Default is no group
        readOnly:
          type: boolean
          description:
            readOnly here will force the Quobyte volume to be mounted with
            read-only permissions. Defaults to false.
        registry:
          type: string
          description:
            registry represents a single or multiple Quobyte Registry services
            specified as a string as host:port pair (multiple entries are separated
            with commas) which acts as the central registry for volumes
        tenant:
          type: string
          description:
            "tenant owning the given Quobyte volume in the Backend Used\
            \ with dynamically provisioned Quobyte volumes, value is set by the plugin"
        user:
          type: string
          description: user to map volume access to Defaults to serivceaccount user
        volume:
          type: string
          description:
            volume is a string that references an already created Quobyte
            volume by name.
      description:
        Represents a Quobyte mount that lasts the lifetime of a pod. Quobyte
        volumes do not support ownership management or SELinux relabeling.
    io.k8s.api.core.v1.RBDVolumeSource:
      required:
        - image
        - monitors
      type: object
      properties:
        fsType:
          type: string
          description:
            "fsType is the filesystem type of the volume that you want\
            \ to mount. Tip: Ensure that the filesystem type is supported by the host\
            \ operating system. Examples: \"ext4\", \"xfs\", \"ntfs\". Implicitly\
            \ inferred to be \"ext4\" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd"
        image:
          type: string
          description: "image is the rados image name. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it"
        keyring:
          type: string
          description:
            "keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring.\
            \ More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it"
        monitors:
          type: array
          description: "monitors is a collection of Ceph monitors. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it"
          items:
            type: string
        pool:
          type: string
          description: "pool is the rados pool name. Default is rbd. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it"
        readOnly:
          type: boolean
          description:
            "readOnly here will force the ReadOnly setting in VolumeMounts.\
            \ Defaults to false. More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it"
        secretRef:
          $ref: "#/components/schemas/io.k8s.api.core.v1.LocalObjectReference"
        user:
          type: string
          description:
            "user is the rados user name. Default is admin. More info:\
            \ https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it"
      description:
        Represents a Rados Block Device mount that lasts the lifetime of
        a pod. RBD volumes support ownership management and SELinux relabeling.
    io.k8s.api.core.v1.ScaleIOVolumeSource:
      required:
        - gateway
        - secretRef
        - system
      type: object
      properties:
        fsType:
          type: string
          description:
            "fsType is the filesystem type to mount. Must be a filesystem\
            \ type supported by the host operating system. Ex. \"ext4\", \"xfs\",\
            \ \"ntfs\". Default is \"xfs\"."
        gateway:
          type: string
          description: gateway is the host address of the ScaleIO API Gateway.
        protectionDomain:
          type: string
          description:
            protectionDomain is the name of the ScaleIO Protection Domain
            for the configured storage.
        readOnly:
          type: boolean
          description:
            readOnly Defaults to false (read/write). ReadOnly here will
            force the ReadOnly setting in VolumeMounts.
        secretRef:
          $ref: "#/components/schemas/io.k8s.api.core.v1.LocalObjectReference"
        sslEnabled:
          type: boolean
          description:
            "sslEnabled Flag enable/disable SSL communication with Gateway,\
            \ default false"
        storageMode:
          type: string
          description:
            storageMode indicates whether the storage for a volume should
            be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.
        storagePool:
          type: string
          description:
            storagePool is the ScaleIO Storage Pool associated with the
            protection domain.
        system:
          type: string
          description: system is the name of the storage system as configured in ScaleIO.
        volumeName:
          type: string
          description:
            volumeName is the name of a volume already created in the ScaleIO
            system that is associated with this volume source.
      description: ScaleIOVolumeSource represents a persistent ScaleIO volume
    io.k8s.api.core.v1.SecretVolumeSource:
      type: object
      properties:
        defaultMode:
          type: integer
          description:
            "defaultMode is Optional: mode bits used to set permissions\
            \ on created files by default. Must be an octal value between 0000 and\
            \ 0777 or a decimal value between 0 and 511. YAML accepts both octal and\
            \ decimal values, JSON requires decimal values for mode bits. Defaults\
            \ to 0644. Directories within the path are not affected by this setting.\
            \ This might be in conflict with other options that affect the file mode,\
            \ like fsGroup, and the result can be other mode bits set."
          format: int32
        items:
          type: array
          description:
            "items If unspecified, each key-value pair in the Data field\
            \ of the referenced Secret will be projected into the volume as a file\
            \ whose name is the key and content is the value. If specified, the listed\
            \ keys will be projected into the specified paths, and unlisted keys will\
            \ not be present. If a key is specified which is not present in the Secret,\
            \ the volume setup will error unless it is marked optional. Paths must\
            \ be relative and may not contain the '..' path or start with '..'."
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.KeyToPath"
        optional:
          type: boolean
          description:
            optional field specify whether the Secret or its keys must
            be defined
        secretName:
          type: string
          description:
            "secretName is the name of the secret in the pod's namespace\
            \ to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret"
      description: |-
        Adapts a Secret into a volume.

        The contents of the target Secret's Data field will be presented in a volume as files using the keys in the Data field as the file names. Secret volumes support ownership management and SELinux relabeling.
    io.k8s.api.core.v1.StorageOSVolumeSource:
      type: object
      properties:
        fsType:
          type: string
          description:
            "fsType is the filesystem type to mount. Must be a filesystem\
            \ type supported by the host operating system. Ex. \"ext4\", \"xfs\",\
            \ \"ntfs\". Implicitly inferred to be \"ext4\" if unspecified."
        readOnly:
          type: boolean
          description:
            readOnly defaults to false (read/write). ReadOnly here will
            force the ReadOnly setting in VolumeMounts.
        secretRef:
          $ref: "#/components/schemas/io.k8s.api.core.v1.LocalObjectReference"
        volumeName:
          type: string
          description:
            volumeName is the human-readable name of the StorageOS volume.  Volume
            names are only unique within a namespace.
        volumeNamespace:
          type: string
          description:
            volumeNamespace specifies the scope of the volume within StorageOS.  If
            no namespace is specified then the Pod's namespace will be used.  This
            allows the Kubernetes name scoping to be mirrored within StorageOS for
            tighter integration. Set VolumeName to any name to override the default
            behaviour. Set to "default" if you are not using namespaces within StorageOS.
            Namespaces that do not pre-exist within StorageOS will be created.
      description: Represents a StorageOS persistent volume resource.
    io.k8s.api.core.v1.VsphereVirtualDiskVolumeSource:
      required:
        - volumePath
      type: object
      properties:
        fsType:
          type: string
          description:
            "fsType is filesystem type to mount. Must be a filesystem type\
            \ supported by the host operating system. Ex. \"ext4\", \"xfs\", \"ntfs\"\
            . Implicitly inferred to be \"ext4\" if unspecified."
        storagePolicyID:
          type: string
          description:
            storagePolicyID is the storage Policy Based Management (SPBM)
            profile ID associated with the StoragePolicyName.
        storagePolicyName:
          type: string
          description:
            storagePolicyName is the storage Policy Based Management (SPBM)
            profile name.
        volumePath:
          type: string
          description: volumePath is the path that identifies vSphere volume vmdk
      description: Represents a vSphere volume resource.
    io.k8s.api.apps.v1.DeploymentStatus:
      type: object
      properties:
        availableReplicas:
          type: integer
          description:
            Total number of available pods (ready for at least minReadySeconds)
            targeted by this deployment.
          format: int32
        collisionCount:
          type: integer
          description:
            Count of hash collisions for the Deployment. The Deployment
            controller uses this field as a collision avoidance mechanism when it
            needs to create the name for the newest ReplicaSet.
          format: int32
        conditions:
          type: array
          description:
            Represents the latest available observations of a deployment's
            current state.
          items:
            $ref: "#/components/schemas/io.k8s.api.apps.v1.DeploymentCondition"
          x-kubernetes-patch-strategy: merge
          x-kubernetes-patch-merge-key: type
        observedGeneration:
          type: integer
          description: The generation observed by the deployment controller.
          format: int64
        readyReplicas:
          type: integer
          description:
            readyReplicas is the number of pods targeted by this Deployment
            with a Ready Condition.
          format: int32
        replicas:
          type: integer
          description:
            Total number of non-terminated pods targeted by this deployment
            (their labels match the selector).
          format: int32
        unavailableReplicas:
          type: integer
          description:
            Total number of unavailable pods targeted by this deployment.
            This is the total number of pods that are still required for the deployment
            to have 100% available capacity. They may either be pods that are running
            but not yet available or pods that still have not been created.
          format: int32
        updatedReplicas:
          type: integer
          description:
            Total number of non-terminated pods targeted by this deployment
            that have the desired template spec.
          format: int32
      description: DeploymentStatus is the most recently observed status of the Deployment.
    io.k8s.api.apps.v1.DeploymentCondition:
      required:
        - status
        - type
      type: object
      properties:
        lastTransitionTime:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        lastUpdateTime:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        message:
          type: string
          description: A human readable message indicating details about the transition.
        reason:
          type: string
          description: The reason for the condition's last transition.
        status:
          type: string
          description: "Status of the condition, one of True, False, Unknown."
        type:
          type: string
          description: Type of deployment condition.
      description:
        DeploymentCondition describes the state of a deployment at a certain
        point.
    io.k8s.api.core.v1.Service:
      type: object
      properties:
        apiVersion:
          type: string
          description:
            "APIVersion defines the versioned schema of this representation\
            \ of an object. Servers should convert recognized schemas to the latest\
            \ internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"
        kind:
          type: string
          description:
            "Kind is a string value representing the REST resource this\
            \ object represents. Servers may infer this from the endpoint the client\
            \ submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        metadata:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        spec:
          $ref: "#/components/schemas/io.k8s.api.core.v1.ServiceSpec"
        status:
          $ref: "#/components/schemas/io.k8s.api.core.v1.ServiceStatus"
      description:
        "Service is a named abstraction of software service (for example,\
        \ mysql) consisting of local port (for example 3306) that the proxy listens\
        \ on, and the selector that determines which pods will answer requests sent\
        \ through the proxy."
      x-kubernetes-group-version-kind:
        - group: ""
          kind: Service
          version: v1
    io.k8s.api.core.v1.ServiceSpec:
      type: object
      properties:
        allocateLoadBalancerNodePorts:
          type: boolean
          description:
            "allocateLoadBalancerNodePorts defines if NodePorts will be\
            \ automatically allocated for services with type LoadBalancer.  Default\
            \ is \"true\". It may be set to \"false\" if the cluster load-balancer\
            \ does not rely on NodePorts.  If the caller requests specific NodePorts\
            \ (by specifying a value), those requests will be respected, regardless\
            \ of this field. This field may only be set for services with type LoadBalancer\
            \ and will be cleared if the type is changed to any other type."
        clusterIP:
          type: string
          description:
            "clusterIP is the IP address of the service and is usually\
            \ assigned randomly. If an address is specified manually, is in-range\
            \ (as per system configuration), and is not in use, it will be allocated\
            \ to the service; otherwise creation of the service will fail. This field\
            \ may not be changed through updates unless the type field is also being\
            \ changed to ExternalName (which requires this field to be blank) or the\
            \ type field is being changed from ExternalName (in which case this field\
            \ may optionally be specified, as describe above).  Valid values are \"\
            None\", empty string (\"\"), or a valid IP address. Setting this to \"\
            None\" makes a \"headless service\" (no virtual IP), which is useful when\
            \ direct endpoint connections are preferred and proxying is not required.\
            \  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this\
            \ field is specified when creating a Service of type ExternalName, creation\
            \ will fail. This field will be wiped when updating a Service to type\
            \ ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies"
        clusterIPs:
          type: array
          description: |-
            ClusterIPs is a list of IP addresses assigned to this service, and are usually assigned randomly.  If an address is specified manually, is in-range (as per system configuration), and is not in use, it will be allocated to the service; otherwise creation of the service will fail. This field may not be changed through updates unless the type field is also being changed to ExternalName (which requires this field to be empty) or the type field is being changed from ExternalName (in which case this field may optionally be specified, as describe above).  Valid values are "None", empty string (""), or a valid IP address.  Setting this to "None" makes a "headless service" (no virtual IP), which is useful when direct endpoint connections are preferred and proxying is not required.  Only applies to types ClusterIP, NodePort, and LoadBalancer. If this field is specified when creating a Service of type ExternalName, creation will fail. This field will be wiped when updating a Service to type ExternalName.  If this field is not specified, it will be initialized from the clusterIP field.  If this field is specified, clients must ensure that clusterIPs[0] and clusterIP have the same value.

            This field may hold a maximum of two entries (dual-stack IPs, in either order). These IPs must correspond to the values of the ipFamilies field. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
          items:
            type: string
          x-kubernetes-list-type: atomic
        externalIPs:
          type: array
          description:
            externalIPs is a list of IP addresses for which nodes in the
            cluster will also accept traffic for this service.  These IPs are not
            managed by Kubernetes.  The user is responsible for ensuring that traffic
            arrives at a node with this IP.  A common example is external load-balancers
            that are not part of the Kubernetes system.
          items:
            type: string
        externalName:
          type: string
          description:
            externalName is the external reference that discovery mechanisms
            will return as an alias for this service (e.g. a DNS CNAME record). No
            proxying will be involved.  Must be a lowercase RFC-1123 hostname (https://tools.ietf.org/html/rfc1123)
            and requires `type` to be "ExternalName".
        externalTrafficPolicy:
          type: string
          description: |-
            externalTrafficPolicy describes how nodes distribute service traffic they receive on one of the Service's "externally-facing" addresses (NodePorts, ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure the service in a way that assumes that external load balancers will take care of balancing the service traffic between nodes, and so each node will deliver traffic only to the node-local endpoints of the service, without masquerading the client source IP. (Traffic mistakenly sent to a node with no endpoints will be dropped.) The default value, "Cluster", uses the standard behavior of routing to all endpoints evenly (possibly modified by topology and other features). Note that traffic sent to an External IP or LoadBalancer IP from within the cluster will always get "Cluster" semantics, but clients sending to a NodePort from within the cluster may need to take traffic policy into account when picking a node.

            Possible enum values:
             - `"Cluster"`
             - `"Cluster"` routes traffic to all endpoints.
             - `"Local"`
             - `"Local"` preserves the source IP of the traffic by routing only to endpoints on the same node as the traffic was received on (dropping the traffic if there are no local endpoints).
          enum:
            - Cluster
            - Local
        healthCheckNodePort:
          type: integer
          description:
            "healthCheckNodePort specifies the healthcheck nodePort for\
            \ the service. This only applies when type is set to LoadBalancer and\
            \ externalTrafficPolicy is set to Local. If a value is specified, is in-range,\
            \ and is not in use, it will be used.  If not specified, a value will\
            \ be automatically allocated.  External systems (e.g. load-balancers)\
            \ can use this port to determine if a given node holds endpoints for this\
            \ service or not.  If this field is specified when creating a Service\
            \ which does not need it, creation will fail. This field will be wiped\
            \ when updating a Service to no longer need it (e.g. changing type). This\
            \ field cannot be updated once set."
          format: int32
        internalTrafficPolicy:
          type: string
          description: |-
            InternalTrafficPolicy describes how nodes distribute service traffic they receive on the ClusterIP. If set to "Local", the proxy will assume that pods only want to talk to endpoints of the service on the same node as the pod, dropping the traffic if there are no local endpoints. The default value, "Cluster", uses the standard behavior of routing to all endpoints evenly (possibly modified by topology and other features).

            Possible enum values:
             - `"Cluster"` routes traffic to all endpoints.
             - `"Local"` routes traffic only to endpoints on the same node as the client pod (dropping the traffic if there are no local endpoints).
          enum:
            - Cluster
            - Local
        ipFamilies:
          type: array
          description: |-
            IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this service. This field is usually assigned automatically based on cluster configuration and the ipFamilyPolicy field. If this field is specified manually, the requested family is available in the cluster, and ipFamilyPolicy allows it, it will be used; otherwise creation of the service will fail. This field is conditionally mutable: it allows for adding or removing a secondary IP family, but it does not allow changing the primary IP family of the Service. Valid values are "IPv4" and "IPv6".  This field only applies to Services of types ClusterIP, NodePort, and LoadBalancer, and does apply to "headless" services. This field will be wiped when updating a Service to type ExternalName.

            This field may hold a maximum of two entries (dual-stack families, in either order).  These families must correspond to the values of the clusterIPs field, if specified. Both clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
          items:
            type: string
          x-kubernetes-list-type: atomic
        ipFamilyPolicy:
          type: string
          description: |-
            IPFamilyPolicy represents the dual-stack-ness requested or required by this Service. If there is no value provided, then this field will be set to SingleStack. Services can be "SingleStack" (a single IP family), "PreferDualStack" (two IP families on dual-stack configured clusters or a single IP family on single-stack clusters), or "RequireDualStack" (two IP families on dual-stack configured clusters, otherwise fail). The ipFamilies and clusterIPs fields depend on the value of this field. This field will be wiped when updating a service to type ExternalName.

            Possible enum values:
             - `"PreferDualStack"` indicates that this service prefers dual-stack when the cluster is configured for dual-stack. If the cluster is not configured for dual-stack the service will be assigned a single IPFamily. If the IPFamily is not set in service.spec.ipFamilies then the service will be assigned the default IPFamily configured on the cluster
             - `"RequireDualStack"` indicates that this service requires dual-stack. Using IPFamilyPolicyRequireDualStack on a single stack cluster will result in validation errors. The IPFamilies (and their order) assigned to this service is based on service.spec.ipFamilies. If service.spec.ipFamilies was not provided then it will be assigned according to how they are configured on the cluster. If service.spec.ipFamilies has only one entry then the alternative IPFamily will be added by apiserver
             - `"SingleStack"` indicates that this service is required to have a single IPFamily. The IPFamily assigned is based on the default IPFamily used by the cluster or as identified by service.spec.ipFamilies field
          enum:
            - PreferDualStack
            - RequireDualStack
            - SingleStack
        loadBalancerClass:
          type: string
          description:
            "loadBalancerClass is the class of the load balancer implementation\
            \ this Service belongs to. If specified, the value of this field must\
            \ be a label-style identifier, with an optional prefix, e.g. \"internal-vip\"\
            \ or \"example.com/internal-vip\". Unprefixed names are reserved for end-users.\
            \ This field can only be set when the Service type is 'LoadBalancer'.\
            \ If not set, the default load balancer implementation is used, today\
            \ this is typically done through the cloud provider integration, but should\
            \ apply for any default implementation. If set, it is assumed that a load\
            \ balancer implementation is watching for Services with a matching class.\
            \ Any default load balancer implementation (e.g. cloud providers) should\
            \ ignore Services that set this field. This field can only be set when\
            \ creating or updating a Service to type 'LoadBalancer'. Once set, it\
            \ can not be changed. This field will be wiped when a service is updated\
            \ to a non 'LoadBalancer' type."
        loadBalancerIP:
          type: string
          description:
            "Only applies to Service Type: LoadBalancer. This feature depends\
            \ on whether the underlying cloud-provider supports specifying the loadBalancerIP\
            \ when a load balancer is created. This field will be ignored if the cloud-provider\
            \ does not support the feature. Deprecated: This field was under-specified\
            \ and its meaning varies across implementations. Using it is non-portable\
            \ and it may not support dual-stack. Users are encouraged to use implementation-specific\
            \ annotations when available."
        loadBalancerSourceRanges:
          type: array
          description:
            "If specified and supported by the platform, this will restrict\
            \ traffic through the cloud-provider load-balancer will be restricted\
            \ to the specified client IPs. This field will be ignored if the cloud-provider\
            \ does not support the feature.\" More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/"
          items:
            type: string
        ports:
          type: array
          description:
            "The list of ports that are exposed by this service. More info:\
            \ https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies"
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.ServicePort"
          x-kubernetes-patch-strategy: merge
          x-kubernetes-list-type: map
          x-kubernetes-list-map-keys:
            - port
            - protocol
          x-kubernetes-patch-merge-key: port
        publishNotReadyAddresses:
          type: boolean
          description:
            publishNotReadyAddresses indicates that any agent which deals
            with endpoints for this Service should disregard any indications of ready/not-ready.
            The primary use case for setting this field is for a StatefulSet's Headless
            Service to propagate SRV DNS records for its Pods for the purpose of peer
            discovery. The Kubernetes controllers that generate Endpoints and EndpointSlice
            resources for Services interpret this to mean that all endpoints are considered
            "ready" even if the Pods themselves are not. Agents which consume only
            Kubernetes generated endpoints through the Endpoints or EndpointSlice
            resources can safely assume this behavior.
        selector:
          type: object
          additionalProperties:
            type: string
          description:
            "Route service traffic to pods with label keys and values matching\
            \ this selector. If empty or not present, the service is assumed to have\
            \ an external process managing its endpoints, which Kubernetes will not\
            \ modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.\
            \ Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/"
          x-kubernetes-map-type: atomic
        sessionAffinity:
          type: string
          description: |-
            Supports "ClientIP" and "None". Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies

            Possible enum values:
             - `"ClientIP"` is the Client IP based.
             - `"None"` - no session affinity.
          enum:
            - ClientIP
            - None
        sessionAffinityConfig:
          $ref: "#/components/schemas/io.k8s.api.core.v1.SessionAffinityConfig"
        type:
          type: string
          description: |-
            type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object or EndpointSlice objects. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a virtual IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the same endpoints as the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the same endpoints as the clusterIP. "ExternalName" aliases this service to the specified externalName. Several other fields do not apply to ExternalName services. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types

            Possible enum values:
             - `"ClusterIP"` means a service will only be accessible inside the cluster, via the cluster IP.
             - `"ExternalName"` means a service consists of only a reference to an external name that kubedns or equivalent will return as a CNAME record, with no exposing or proxying of any pods involved.
             - `"LoadBalancer"` means a service will be exposed via an external load balancer (if the cloud provider supports it), in addition to 'NodePort' type.
             - `"NodePort"` means a service will be exposed on one port of every node, in addition to 'ClusterIP' type.
          enum:
            - ClusterIP
            - ExternalName
            - LoadBalancer
            - NodePort
      description: ServiceSpec describes the attributes that a user creates on a service.
    io.k8s.api.core.v1.ServicePort:
      required:
        - port
      type: object
      properties:
        appProtocol:
          type: string
          description: |-
            The application protocol for this port. This is used as a hint for implementations to offer richer behavior for protocols that they understand. This field follows standard Kubernetes label syntax. Valid values are either:

            * Un-prefixed protocol names - reserved for IANA standard service names (as per RFC-6335 and https://www.iana.org/assignments/service-names).

            * Kubernetes-defined prefixed names:
              * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
              * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
              * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455

            * Other protocols should use implementation-defined prefixed names such as mycompany.com/my-custom-protocol.
        name:
          type: string
          description:
            "The name of this port within the service. This must be a DNS_LABEL.\
            \ All ports within a ServiceSpec must have unique names. When considering\
            \ the endpoints for a Service, this must match the 'name' field in the\
            \ EndpointPort. Optional if only one ServicePort is defined on this service."
        nodePort:
          type: integer
          description:
            "The port on each node on which this service is exposed when\
            \ type is NodePort or LoadBalancer.  Usually assigned by the system. If\
            \ a value is specified, in-range, and not in use it will be used, otherwise\
            \ the operation will fail.  If not specified, a port will be allocated\
            \ if this Service requires one.  If this field is specified when creating\
            \ a Service which does not need it, creation will fail. This field will\
            \ be wiped when updating a Service to no longer need it (e.g. changing\
            \ type from NodePort to ClusterIP). More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport"
          format: int32
        port:
          type: integer
          description: The port that will be exposed by this service.
          format: int32
        protocol:
          type: string
          description: |-
            The IP protocol for this port. Supports "TCP", "UDP", and "SCTP". Default is TCP.

            Possible enum values:
             - `"SCTP"` is the SCTP protocol.
             - `"TCP"` is the TCP protocol.
             - `"UDP"` is the UDP protocol.
          enum:
            - SCTP
            - TCP
            - UDP
        targetPort:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.util.intstr.IntOrString"
      description: ServicePort contains information on service's port.
    io.k8s.api.core.v1.SessionAffinityConfig:
      type: object
      properties:
        clientIP:
          $ref: "#/components/schemas/io.k8s.api.core.v1.ClientIPConfig"
      description:
        SessionAffinityConfig represents the configurations of session
        affinity.
    io.k8s.api.core.v1.ClientIPConfig:
      type: object
      properties:
        timeoutSeconds:
          type: integer
          description:
            timeoutSeconds specifies the seconds of ClientIP type session
            sticky time. The value must be >0 && <=86400(for 1 day) if ServiceAffinity
            == "ClientIP". Default value is 10800(for 3 hours).
          format: int32
      description:
        ClientIPConfig represents the configurations of Client IP based
        session affinity.
    io.k8s.api.core.v1.ServiceStatus:
      type: object
      properties:
        conditions:
          type: array
          description: Current service state
          items:
            $ref: "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Condition"
          x-kubernetes-patch-strategy: merge
          x-kubernetes-list-type: map
          x-kubernetes-list-map-keys:
            - type
          x-kubernetes-patch-merge-key: type
        loadBalancer:
          $ref: "#/components/schemas/io.k8s.api.core.v1.LoadBalancerStatus"
      description: ServiceStatus represents the current status of a service.
    io.k8s.apimachinery.pkg.apis.meta.v1.Condition:
      required:
        - lastTransitionTime
        - message
        - reason
        - status
        - type
      type: object
      properties:
        lastTransitionTime:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        message:
          type: string
          description:
            message is a human readable message indicating details about
            the transition. This may be an empty string.
        observedGeneration:
          type: integer
          description:
            "observedGeneration represents the .metadata.generation that\
            \ the condition was set based upon. For instance, if .metadata.generation\
            \ is currently 12, but the .status.conditions[x].observedGeneration is\
            \ 9, the condition is out of date with respect to the current state of\
            \ the instance."
          format: int64
        reason:
          type: string
          description:
            "reason contains a programmatic identifier indicating the reason\
            \ for the condition's last transition. Producers of specific condition\
            \ types may define expected values and meanings for this field, and whether\
            \ the values are considered a guaranteed API. The value should be a CamelCase\
            \ string. This field may not be empty."
        status:
          type: string
          description: "status of the condition, one of True, False, Unknown."
        type:
          type: string
          description: type of condition in CamelCase or in foo.example.com/CamelCase.
      description:
        Condition contains details for one aspect of the current state
        of this API Resource.
    io.k8s.api.core.v1.LoadBalancerStatus:
      type: object
      properties:
        ingress:
          type: array
          description:
            Ingress is a list containing ingress points for the load-balancer.
            Traffic intended for the service should be sent to these ingress points.
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.LoadBalancerIngress"
      description: LoadBalancerStatus represents the status of a load-balancer.
    io.k8s.api.core.v1.LoadBalancerIngress:
      type: object
      properties:
        hostname:
          type: string
          description:
            Hostname is set for load-balancer ingress points that are DNS
            based (typically AWS load-balancers)
        ip:
          type: string
          description:
            IP is set for load-balancer ingress points that are IP based
            (typically GCE or OpenStack load-balancers)
        ipMode:
          type: string
          description:
            "IPMode specifies how the load-balancer IP behaves, and may\
            \ only be specified when the ip field is specified. Setting this to \"\
            VIP\" indicates that traffic is delivered to the node with the destination\
            \ set to the load-balancer's IP and port. Setting this to \"Proxy\" indicates\
            \ that traffic is delivered to the node or pod with the destination set\
            \ to the node's IP and node port or the pod's IP and port. Service implementations\
            \ may use this information to adjust traffic routing."
        ports:
          type: array
          description:
            "Ports is a list of records of service ports If used, every\
            \ port defined in the service should have an entry in it"
          items:
            $ref: "#/components/schemas/io.k8s.api.core.v1.PortStatus"
          x-kubernetes-list-type: atomic
      description:
        "LoadBalancerIngress represents the status of a load-balancer ingress\
        \ point: traffic intended for the service should be sent to an ingress point."
    io.k8s.api.core.v1.PortStatus:
      required:
        - port
        - protocol
      type: object
      properties:
        error:
          type: string
          description: |-
            Error is to record the problem with the service port The format of the error shall comply with the following rules: - built-in error values shall be specified in this file and those shall use
              CamelCase names
            - cloud provider specific error values must have names that comply with the
              format foo.example.com/CamelCase.
        port:
          type: integer
          description:
            Port is the port number of the service port of which status
            is recorded here
          format: int32
        protocol:
          type: string
          description: |-
            Protocol is the protocol of the service port of which status is recorded here The supported values are: "TCP", "UDP", "SCTP"

            Possible enum values:
             - `"SCTP"` is the SCTP protocol.
             - `"TCP"` is the TCP protocol.
             - `"UDP"` is the UDP protocol.
          enum:
            - SCTP
            - TCP
            - UDP
    com.github.openshift.api.route.v1.Route:
      required:
        - spec
      type: object
      properties:
        apiVersion:
          type: string
          description:
            "APIVersion defines the versioned schema of this representation\
            \ of an object. Servers should convert recognized schemas to the latest\
            \ internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources"
        kind:
          type: string
          description:
            "Kind is a string value representing the REST resource this\
            \ object represents. Servers may infer this from the endpoint the client\
            \ submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds"
        metadata:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta"
        spec:
          $ref: "#/components/schemas/com.github.openshift.api.route.v1.RouteSpec"
        status:
          $ref: "#/components/schemas/com.github.openshift.api.route.v1.RouteStatus"
      description: |-
        A route allows developers to expose services through an HTTP(S) aware load balancing and proxy layer via a public DNS entry. The route may further specify TLS options and a certificate, or specify a public CNAME that the router should also accept for HTTP and HTTPS traffic. An administrator typically configures their router to be visible outside the cluster firewall, and may also add additional security, caching, or traffic controls on the service content. Routers usually talk directly to the service endpoints.

        Once a route is created, the `host` field may not be changed. Generally, routers use the oldest route with a given host when resolving conflicts.

        Routers are subject to additional customization and may support additional controls via the annotations field.

        Because administrators may configure multiple routers, the route status field is used to return information to clients about the names and states of the route under each router. If a client chooses a duplicate name, for instance, the route status conditions are used to indicate the route cannot be chosen.

        To enable HTTP/2 ALPN on a route it requires a custom (non-wildcard) certificate. This prevents connection coalescing by clients, notably web browsers. We do not support HTTP/2 ALPN on routes that use the default certificate because of the risk of connection re-use/coalescing. Routes that do not have their own custom certificate will not be HTTP/2 ALPN-enabled on either the frontend or the backend.

        Compatibility level 1: Stable within a major release for a minimum of 12 months or 3 minor releases (whichever is longer).
      x-kubernetes-group-version-kind:
        - group: ""
          kind: Route
          version: v1
        - group: route.openshift.io
          kind: Route
          version: v1
    com.github.openshift.api.route.v1.RouteSpec:
      required:
        - to
      type: object
      properties:
        alternateBackends:
          type: array
          description:
            "alternateBackends allows up to 3 additional backends to be\
            \ assigned to the route. Only the Service kind is allowed, and it will\
            \ be defaulted to Service. Use the weight field in RouteTargetReference\
            \ object to specify relative preference."
          items:
            $ref: "#/components/schemas/com.github.openshift.api.route.v1.RouteTargetReference"
        host:
          type: string
          description:
            host is an alias/DNS that points to the service. Optional.
            If not specified a route name will typically be automatically chosen.
            Must follow DNS952 subdomain conventions.
        httpHeaders:
          $ref: "#/components/schemas/com.github.openshift.api.route.v1.RouteHTTPHeaders"
        path:
          type: string
          description:
            "path that the router watches for, to route traffic for to\
            \ the service. Optional"
        port:
          $ref: "#/components/schemas/com.github.openshift.api.route.v1.RoutePort"
        subdomain:
          type: string
          description: |-
            subdomain is a DNS subdomain that is requested within the ingress controller's domain (as a subdomain). If host is set this field is ignored. An ingress controller may choose to ignore this suggested name, in which case the controller will report the assigned name in the status.ingress array or refuse to admit the route. If this value is set and the server does not support this field host will be populated automatically. Otherwise host is left empty. The field may have multiple parts separated by a dot, but not all ingress controllers may honor the request. This field may not be changed after creation except by a user with the update routes/custom-host permission.

            Example: subdomain `frontend` automatically receives the router subdomain `apps.mycluster.com` to have a full hostname `frontend.apps.mycluster.com`.
        tls:
          $ref: "#/components/schemas/com.github.openshift.api.route.v1.TLSConfig"
        to:
          $ref: "#/components/schemas/com.github.openshift.api.route.v1.RouteTargetReference"
        wildcardPolicy:
          type: string
          description:
            Wildcard policy if any for the route. Currently only 'Subdomain'
            or 'None' is allowed.
      description: |-
        RouteSpec describes the hostname or path the route exposes, any security information, and one to four backends (services) the route points to. Requests are distributed among the backends depending on the weights assigned to each backend. When using roundrobin scheduling the portion of requests that go to each backend is the backend weight divided by the sum of all of the backend weights. When the backend has more than one endpoint the requests that end up on the backend are roundrobin distributed among the endpoints. Weights are between 0 and 256 with default 100. Weight 0 causes no requests to the backend. If all weights are zero the route will be considered to have no backends and return a standard 503 response.

        The `tls` field is optional and allows specific certificates or behavior for the route. Routers typically configure a default certificate on a wildcard domain to terminate routes without explicit certificates, but custom hostnames usually must choose passthrough (send traffic directly to the backend via the TLS Server-Name- Indication field) or provide a certificate.
    com.github.openshift.api.route.v1.RouteTargetReference:
      required:
        - kind
        - name
      type: object
      properties:
        kind:
          type: string
          description:
            "The kind of target that the route is referring to. Currently,\
            \ only 'Service' is allowed"
        name:
          type: string
          description:
            name of the service/target that is being referred to. e.g.
            name of the service
        weight:
          type: integer
          description:
            "weight as an integer between 0 and 256, default 100, that\
            \ specifies the target's relative weight against other target reference\
            \ objects. 0 suppresses requests to this backend."
          format: int32
      description:
        RouteTargetReference specifies the target that resolve into endpoints.
        Only the 'Service' kind is allowed. Use 'weight' field to emphasize one over
        others.
    com.github.openshift.api.route.v1.RouteHTTPHeaders:
      type: object
      properties:
        actions:
          $ref: "#/components/schemas/com.github.openshift.api.route.v1.RouteHTTPHeaderActions"
      description: RouteHTTPHeaders defines policy for HTTP headers.
    com.github.openshift.api.route.v1.RouteHTTPHeaderActions:
      type: object
      properties:
        request:
          type: array
          description:
            "request is a list of HTTP request headers to modify. Currently,\
            \ actions may define to either `Set` or `Delete` headers values. Actions\
            \ defined here will modify the request headers of all requests made through\
            \ a route. These actions are applied to a specific Route defined within\
            \ a cluster i.e. connections made through a route. Currently, actions\
            \ may define to either `Set` or `Delete` headers values. Route actions\
            \ will be executed after IngressController actions for request headers.\
            \ Actions are applied in sequence as defined in this list. A maximum of\
            \ 20 request header actions may be configured. You can use this field\
            \ to specify HTTP request headers that should be set or deleted when forwarding\
            \ connections from the client to your application. Sample fetchers allowed\
            \ are \"req.hdr\" and \"ssl_c_der\". Converters allowed are \"lower\"\
            \ and \"base64\". Example header values: \"%[req.hdr(X-target),lower]\"\
            , \"%{+Q}[ssl_c_der,base64]\". Any request header configuration applied\
            \ directly via a Route resource using this API will override header configuration\
            \ for a header of the same name applied via spec.httpHeaders.actions on\
            \ the IngressController or route annotation. Note: This field cannot be\
            \ used if your route uses TLS passthrough."
          items:
            $ref: "#/components/schemas/com.github.openshift.api.route.v1.RouteHTTPHeader"
          x-kubernetes-list-type: map
          x-kubernetes-list-map-keys:
            - name
        response:
          type: array
          description:
            "response is a list of HTTP response headers to modify. Currently,\
            \ actions may define to either `Set` or `Delete` headers values. Actions\
            \ defined here will modify the response headers of all requests made through\
            \ a route. These actions are applied to a specific Route defined within\
            \ a cluster i.e. connections made through a route. Route actions will\
            \ be executed before IngressController actions for response headers. Actions\
            \ are applied in sequence as defined in this list. A maximum of 20 response\
            \ header actions may be configured. You can use this field to specify\
            \ HTTP response headers that should be set or deleted when forwarding\
            \ responses from your application to the client. Sample fetchers allowed\
            \ are \"res.hdr\" and \"ssl_c_der\". Converters allowed are \"lower\"\
            \ and \"base64\". Example header values: \"%[res.hdr(X-target),lower]\"\
            , \"%{+Q}[ssl_c_der,base64]\". Note: This field cannot be used if your\
            \ route uses TLS passthrough."
          items:
            $ref: "#/components/schemas/com.github.openshift.api.route.v1.RouteHTTPHeader"
          x-kubernetes-list-type: map
          x-kubernetes-list-map-keys:
            - name
      description:
        RouteHTTPHeaderActions defines configuration for actions on HTTP
        request and response headers.
    com.github.openshift.api.route.v1.RouteHTTPHeader:
      required:
        - action
        - name
      type: object
      properties:
        action:
          $ref: "#/components/schemas/com.github.openshift.api.route.v1.RouteHTTPHeaderActionUnion"
        name:
          type: string
          description:
            "name specifies the name of a header on which to perform an\
            \ action. Its value must be a valid HTTP header name as defined in RFC\
            \ 2616 section 4.2. The name must consist only of alphanumeric and the\
            \ following special characters, \"-!#$%&'*+.^_`\". The following header\
            \ names are reserved and may not be modified via this API: Strict-Transport-Security,\
            \ Proxy, Cookie, Set-Cookie. It must be no more than 255 characters in\
            \ length. Header name must be unique."
      description:
        RouteHTTPHeader specifies configuration for setting or deleting
        an HTTP header.
    com.github.openshift.api.route.v1.RouteHTTPHeaderActionUnion:
      required:
        - type
      type: object
      properties:
        set:
          $ref: "#/components/schemas/com.github.openshift.api.route.v1.RouteSetHTTPHeader"
        type:
          type: string
          description:
            type defines the type of the action to be applied on the header.
            Possible values are Set or Delete. Set allows you to set HTTP request
            and response headers. Delete allows you to delete HTTP request and response
            headers.
      description:
        RouteHTTPHeaderActionUnion specifies an action to take on an HTTP
        header.
      x-kubernetes-unions:
        - discriminator: type
          fields-to-discriminateBy:
            set: Set
    com.github.openshift.api.route.v1.RouteSetHTTPHeader:
      required:
        - value
      type: object
      properties:
        value:
          type: string
          description:
            "value specifies a header value. Dynamic values can be added.\
            \ The value will be interpreted as an HAProxy format string as defined\
            \ in http://cbonte.github.io/haproxy-dconv/2.6/configuration.html#8.2.6\
            \ and may use HAProxy's %[] syntax and otherwise must be a valid HTTP\
            \ header value as defined in https://datatracker.ietf.org/doc/html/rfc7230#section-3.2.\
            \ The value of this field must be no more than 16384 characters in length.\
            \ Note that the total size of all net added headers *after* interpolating\
            \ dynamic values must not exceed the value of spec.tuningOptions.headerBufferMaxRewriteBytes\
            \ on the IngressController."
      description:
        RouteSetHTTPHeader specifies what value needs to be set on an HTTP
        header.
    com.github.openshift.api.route.v1.RoutePort:
      required:
        - targetPort
      type: object
      properties:
        targetPort:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.util.intstr.IntOrString"
      description:
        RoutePort defines a port mapping from a router to an endpoint in
        the service endpoints.
    com.github.openshift.api.route.v1.TLSConfig:
      required:
        - termination
      type: object
      properties:
        caCertificate:
          type: string
          description: caCertificate provides the cert authority certificate contents
        certificate:
          type: string
          description:
            "certificate provides certificate contents. This should be\
            \ a single serving certificate, not a certificate chain. Do not include\
            \ a CA certificate."
        destinationCACertificate:
          type: string
          description:
            "destinationCACertificate provides the contents of the ca certificate\
            \ of the final destination.  When using reencrypt termination this file\
            \ should be provided in order to have routers use it for health checks\
            \ on the secure connection. If this field is not specified, the router\
            \ may provide its own destination CA and perform hostname validation using\
            \ the short service name (service.namespace.svc), which allows infrastructure\
            \ generated certificates to automatically verify."
        externalCertificate:
          $ref: "#/components/schemas/com.github.openshift.api.route.v1.LocalObjectReference"
        insecureEdgeTerminationPolicy:
          type: string
          description: |-
            insecureEdgeTerminationPolicy indicates the desired behavior for insecure connections to a route. While each router may make its own decisions on which ports to expose, this is normally port 80.

            If a route does not specify insecureEdgeTerminationPolicy, then the default behavior is "None".

            * Allow - traffic is sent to the server on the insecure port (edge/reencrypt terminations only).

            * None - no traffic is allowed on the insecure port (default).

            * Redirect - clients are redirected to the secure port.
        key:
          type: string
          description: key provides key file contents
        termination:
          type: string
          description: |-
            termination indicates termination type.

            * edge - TLS termination is done by the router and http is used to communicate with the backend (default) * passthrough - Traffic is sent straight to the destination without the router providing TLS termination * reencrypt - TLS termination is done by the router and https is used to communicate with the backend

            Note: passthrough termination is incompatible with httpHeader actions
      description: TLSConfig defines config used to secure a route and provide termination
    com.github.openshift.api.route.v1.LocalObjectReference:
      type: object
      properties:
        name:
          type: string
          description: "name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"
      description:
        LocalObjectReference contains enough information to let you locate
        the referenced object inside the same namespace.
      x-kubernetes-map-type: atomic
    com.github.openshift.api.route.v1.RouteStatus:
      type: object
      properties:
        ingress:
          type: array
          description:
            ingress describes the places where the route may be exposed.
            The list of ingress points may contain duplicate Host or RouterName values.
            Routes are considered live once they are `Ready`
          items:
            $ref: "#/components/schemas/com.github.openshift.api.route.v1.RouteIngress"
      description:
        "RouteStatus provides relevant info about the status of a route,\
        \ including which routers acknowledge it."
    com.github.openshift.api.route.v1.RouteIngress:
      type: object
      properties:
        conditions:
          type: array
          description: "Conditions is the state of the route, may be empty."
          items:
            $ref: "#/components/schemas/com.github.openshift.api.route.v1.RouteIngressCondition"
        host:
          type: string
          description:
            Host is the host string under which the route is exposed; this
            value is required
        routerCanonicalHostname:
          type: string
          description:
            CanonicalHostname is the external host name for the router
            that can be used as a CNAME for the host requested for this route. This
            value is optional and may not be set in all cases.
        routerName:
          type: string
          description:
            Name is a name chosen by the router to identify itself; this
            value is required
        wildcardPolicy:
          type: string
          description:
            Wildcard policy is the wildcard policy that was allowed where
            this route is exposed.
      description:
        RouteIngress holds information about the places where a route is
        exposed.
    com.github.openshift.api.route.v1.RouteIngressCondition:
      required:
        - status
        - type
      type: object
      properties:
        lastTransitionTime:
          $ref: "#/components/schemas/io.k8s.apimachinery.pkg.apis.meta.v1.Time"
        message:
          type: string
          description: Human readable message indicating details about last transition.
        reason:
          type: string
          description:
            "(brief) reason for the condition's last transition, and is\
            \ usually a machine and human readable constant"
        status:
          type: string
          description:
            "Status is the status of the condition. Can be True, False,\
            \ Unknown."
        type:
          type: string
          description:
            Type is the type of the condition. Currently only Admitted
            or UnservableInFutureVersions.
      description:
        RouteIngressCondition contains details for the current condition
        of this route on a particular router.
  parameters:
    fieldManager-Qy4HdaTW:
      name: fieldManager
      in: query
      description:
        "fieldManager is a name associated with the actor or entity that\
        \ is making these changes. The value must be less than or 128 characters long,\
        \ and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint."
      schema:
        type: string
  securitySchemes:
    BearerToken:
      type: http
      scheme: bearer
      description: Bearer Token authentication
x-original-swagger-version: "2.0"
